; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28315.0 

	TITLE	g:\c_library\zlib-vs\zlib-1.2.11\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 155  : }

  00033	5d		 pop	 ebp

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  00012	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00015	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 237  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  00031	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00034	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN10@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;
; 214  :         strm->opaque = (voidpf)0;

  0003f	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00042	33 c9		 xor	 ecx, ecx
  00044	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET _zcalloc
  00050	eb 03		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  00052	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  00055	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00059	75 07		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  0005b	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:
  00062	57		 push	 edi

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00063	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00068	6a 01		 push	 1
  0006a	51		 push	 ecx
  0006b	ff d0		 call	 eax
  0006d	8b f8		 mov	 edi, eax
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00072	85 ff		 test	 edi, edi
  00074	75 09		 jne	 SHORT $LN7@inflateIni
  00076	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi

; 237  : }

  0007b	5d		 pop	 ebp
  0007c	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007f	53		 push	 ebx

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;
; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  00080	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  00083	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00086	56		 push	 esi
  00087	89 37		 mov	 DWORD PTR [edi], esi
  00089	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  00090	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00097	e8 00 00 00 00	 call	 _inflateReset2@8
  0009c	8b d8		 mov	 ebx, eax

; 232  :     if (ret != Z_OK) {

  0009e	85 db		 test	 ebx, ebx
  000a0	74 13		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  000a2	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a5	57		 push	 edi
  000a6	ff 76 28	 push	 DWORD PTR [esi+40]
  000a9	ff d1		 call	 ecx
  000ab	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000ae	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000b5	8b c3		 mov	 eax, ebx
  000b7	5b		 pop	 ebx
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi

; 237  : }

  000ba	5d		 pop	 ebp
  000bb	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000be	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  000c3	5e		 pop	 esi

; 237  : }

  000c4	5d		 pop	 ebp
  000c5	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
_copy$3$ = -68						; size = 4
_copy$2$ = -68						; size = 4
_copy$1$ = -68						; size = 4
tv5708 = -68						; size = 4
tv5677 = -68						; size = 4
tv5633 = -68						; size = 4
tv5618 = -68						; size = 4
tv5617 = -68						; size = 4
tv5588 = -68						; size = 4
tv5574 = -68						; size = 4
tv5536 = -68						; size = 4
tv5532 = -68						; size = 4
tv5525 = -68						; size = 4
tv5524 = -68						; size = 4
tv5517 = -68						; size = 4
tv5508 = -68						; size = 4
tv5255 = -68						; size = 4
$T1 = -64						; size = 4
$T2 = -64						; size = 4
$T3 = -64						; size = 4
$T4 = -64						; size = 4
_copy$7$ = -64						; size = 4
tv5583 = -64						; size = 4
tv5581 = -64						; size = 4
tv5554 = -64						; size = 4
tv5542 = -64						; size = 4
tv5539 = -64						; size = 4
tv5538 = -64						; size = 4
tv5531 = -64						; size = 4
_len$1$ = -64						; size = 4
_in$1$ = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -56						; size = 4
$T7 = -56						; size = 4
$T8 = -56						; size = 4
$T9 = -56						; size = 4
_from$1$ = -56						; size = 4
tv5580 = -56						; size = 4
tv5243 = -52						; size = 4
_last$ = -52						; size = 4
_ret$1$ = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -44						; size = 4
$T12 = -44						; size = 4
_copy$4$ = -44						; size = 4
tv5697 = -44						; size = 4
_out$1$ = -40						; size = 4
_put$1$ = -36						; size = 4
_hbuf$ = -32						; size = 4
_left$1$ = -28						; size = 4
$T13 = -24						; size = 4
_bits$1$ = -24						; size = 4
_next$1$ = -20						; size = 4
_have$1$ = -16						; size = 4
_state$1$ = -12						; size = 4
_hold$1$ = -8						; size = 4
tv5680 = -1						; size = 1
tv5679 = -1						; size = 1
tv5493 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 44	 sub	 esp, 68			; 00000044H
  00009	8b ca		 mov	 ecx, edx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	e8 00 00 00 00	 call	 _inflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 87 11 00
	00		 jne	 $LN333@inflate
  0001b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001e	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  00021	85 c0		 test	 eax, eax
  00023	0f 84 79 11 00
	00		 je	 $LN333@inflate
  00029	8b 3a		 mov	 edi, DWORD PTR [edx]
  0002b	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0002e	85 ff		 test	 edi, edi
  00030	75 09		 jne	 SHORT $LN749@inflate
  00032	39 7a 04	 cmp	 DWORD PTR [edx+4], edi
  00035	0f 85 67 11 00
	00		 jne	 $LN333@inflate
$LN749@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;
; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0003b	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  0003e	89 4d f4	 mov	 DWORD PTR _state$1$[ebp], ecx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00041	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00044	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
  00047	3d 3f 3f 00 00	 cmp	 eax, 16191		; 00003f3fH
  0004c	75 1a		 jne	 SHORT $LN4@inflate
  0004e	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
  00055	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00058	8b 3a		 mov	 edi, DWORD PTR [edx]
  0005a	89 45 dc	 mov	 DWORD PTR _put$1$[ebp], eax
  0005d	b8 40 3f 00 00	 mov	 eax, 16192		; 00003f40H
  00062	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00065	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
$LN4@inflate:

; 651  :     LOAD();

  00068	8b 7a 10	 mov	 edi, DWORD PTR [edx+16]

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0006b	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  00070	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00073	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00076	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00079	89 7d e4	 mov	 DWORD PTR _left$1$[ebp], edi
  0007c	89 7d d8	 mov	 DWORD PTR _out$1$[ebp], edi
  0007f	33 ff		 xor	 edi, edi
  00081	89 7d d0	 mov	 DWORD PTR _ret$1$[ebp], edi
  00084	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00087	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0008a	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0008d	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00090	89 5d c4	 mov	 DWORD PTR _in$1$[ebp], ebx
  00093	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00096	0f 87 06 11 00
	00		 ja	 $LN333@inflate
  0009c	0f 1f 40 00	 npad	 4
$LL5@inflate:
  000a0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN815@inflate[eax*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000a7	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000aa	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
  000ad	85 c0		 test	 eax, eax
  000af	75 0c		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000b1	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  000b8	e9 d1 10 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000bd	83 fe 10	 cmp	 esi, 16			; 00000010H
  000c0	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000c2	85 db		 test	 ebx, ebx
  000c4	0f 84 44 05 00
	00		 je	 $LN933@inflate
  000ca	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000cd	8b ce		 mov	 ecx, esi
  000cf	d3 e0		 shl	 eax, cl
  000d1	83 c6 08	 add	 esi, 8
  000d4	4b		 dec	 ebx
  000d5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  000d8	03 d0		 add	 edx, eax
  000da	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  000dd	47		 inc	 edi
  000de	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  000e1	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  000e4	83 fe 10	 cmp	 esi, 16			; 00000010H
  000e7	72 d9		 jb	 SHORT $LL13@inflate
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T1[ebp]
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000ef	a8 02		 test	 al, 2
  000f1	74 54		 je	 SHORT $LN338@inflate
  000f3	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000f9	75 4c		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  000fb	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000ff	75 07		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00101	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  00108	6a 00		 push	 0
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	e8 00 00 00 00	 call	 _crc32@12
  00113	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 668  :                 CRC2(state->check, hold);

  00116	6a 02		 push	 2
  00118	66 c7 45 e0 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  0011e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00121	8d 4d e0	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00124	51		 push	 ecx
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _crc32@12
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 669  :                 INITBITS();

  0012e	33 d2		 xor	 edx, edx
  00130	33 f6		 xor	 esi, esi
  00132	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00135	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00138	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 670  :                 state->mode = FLAGS;

  0013b	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 671  :                 break;

  00142	e9 47 10 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  00147	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0014a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00151	85 c0		 test	 eax, eax
  00153	74 07		 je	 SHORT $LN940@inflate

; 675  :                 state->head->done = -1;

  00155	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN940@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0015c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0015f	a8 01		 test	 al, 1
  00161	0f 84 d6 00 00
	00		 je	 $LN342@inflate
  00167	0f b6 ca	 movzx	 ecx, dl
  0016a	8b c2		 mov	 eax, edx
  0016c	c1 e1 08	 shl	 ecx, 8
  0016f	33 d2		 xor	 edx, edx
  00171	c1 e8 08	 shr	 eax, 8
  00174	03 c1		 add	 eax, ecx
  00176	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0017b	f7 f1		 div	 ecx
  0017d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00180	85 d2		 test	 edx, edx
  00182	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00185	0f 85 b2 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  0018b	8b c2		 mov	 eax, edx
  0018d	24 0f		 and	 al, 15			; 0000000fH
  0018f	3c 08		 cmp	 al, 8
  00191	74 16		 je	 SHORT $LN26@inflate
$LN978@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00193	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00196	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  0019d	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  001a4	e9 e5 0f 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 686  :                 strm->msg = (char *)"unknown compression method";
; 687  :                 state->mode = BAD;
; 688  :                 break;
; 689  :             }
; 690  :             DROPBITS(4);
; 691  :             len = BITS(4) + 8;
; 692  :             if (state->wbits == 0)

  001a9	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  001ac	83 ee 04	 sub	 esi, 4
  001af	c1 ea 04	 shr	 edx, 4
  001b2	8b c2		 mov	 eax, edx
  001b4	89 7d c8	 mov	 DWORD PTR $T8[ebp], edi
  001b7	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ba	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  001bd	83 c0 08	 add	 eax, 8
  001c0	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  001c3	85 ff		 test	 edi, edi
  001c5	89 45 c0	 mov	 DWORD PTR _len$1$[ebp], eax
  001c8	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  001cb	75 06		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001cd	89 41 28	 mov	 DWORD PTR [ecx+40], eax
  001d0	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001d3	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001d6	77 4f		 ja	 SHORT $LN346@inflate
  001d8	3b 45 c8	 cmp	 eax, DWORD PTR $T8[ebp]
  001db	77 4a		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001dd	8b 4d c0	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	d3 e0		 shl	 eax, cl
  001e7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001ea	6a 00		 push	 0
  001ec	6a 00		 push	 0
  001ee	6a 00		 push	 0
  001f0	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001f3	e8 00 00 00 00	 call	 _adler32@12
  001f8	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001fb	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001fe	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00201	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00204	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00207	c1 ea 08	 shr	 edx, 8
  0020a	f7 d2		 not	 edx
  0020c	83 e2 02	 and	 edx, 2
  0020f	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  00215	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 703  :             INITBITS();

  00218	33 d2		 xor	 edx, edx
  0021a	33 f6		 xor	 esi, esi
  0021c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0021f	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             break;

  00222	e9 67 0f 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00227	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0022a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 696  :                 state->mode = BAD;

  00231	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 697  :                 break;

  00238	e9 51 0f 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  0023d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00240	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 682  :                 state->mode = BAD;

  00247	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 683  :                 break;

  0024e	e9 3b 0f 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  00253	83 fe 10	 cmp	 esi, 16			; 00000010H
  00256	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00258	85 db		 test	 ebx, ebx
  0025a	0f 84 ae 03 00
	00		 je	 $LN933@inflate
  00260	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00263	8b ce		 mov	 ecx, esi
  00265	d3 e0		 shl	 eax, cl
  00267	83 c6 08	 add	 esi, 8
  0026a	4b		 dec	 ebx
  0026b	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0026e	03 d0		 add	 edx, eax
  00270	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00273	47		 inc	 edi
  00274	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00277	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0027a	83 fe 10	 cmp	 esi, 16			; 00000010H
  0027d	72 d9		 jb	 SHORT $LL33@inflate
  0027f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  00282	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00285	80 fa 08	 cmp	 dl, 8
  00288	0f 85 05 ff ff
	ff		 jne	 $LN978@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";
; 711  :                 state->mode = BAD;
; 712  :                 break;
; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  0028e	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  00294	74 16		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  00296	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00299	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002a0	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  002a7	e9 e2 0e 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 716  :                 state->mode = BAD;
; 717  :                 break;
; 718  :             }
; 719  :             if (state->head != Z_NULL)

  002ac	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  002af	8b c2		 mov	 eax, edx
  002b1	c1 e8 08	 shr	 eax, 8
  002b4	89 55 c8	 mov	 DWORD PTR $T7[ebp], edx
  002b7	85 f6		 test	 esi, esi
  002b9	74 11		 je	 SHORT $LN653@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  002bb	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  002be	83 e0 01	 and	 eax, 1
  002c1	89 06		 mov	 DWORD PTR [esi], eax
  002c3	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  002c6	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
  002c9	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
$LN653@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002cc	f7 45 c8 00 02
	00 00		 test	 DWORD PTR $T7[ebp], 512	; 00000200H
  002d3	74 20		 je	 SHORT $LN39@inflate
  002d5	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002d9	74 1a		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002db	88 45 e1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  002de	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002e1	6a 02		 push	 2
  002e3	50		 push	 eax
  002e4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002e7	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  002ea	e8 00 00 00 00	 call	 _crc32@12
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002f2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 723  :             INITBITS();

  002f5	33 d2		 xor	 edx, edx

; 724  :             state->mode = TIME;

  002f7	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002fe	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00301	33 f6		 xor	 esi, esi

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  00303	eb 0b		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  00305	83 fe 20	 cmp	 esi, 32			; 00000020H
  00308	73 2d		 jae	 SHORT $LN44@inflate
  0030a	66 0f 1f 44 00
	00		 npad	 6
$LL47@inflate:
  00310	85 db		 test	 ebx, ebx
  00312	0f 84 f6 02 00
	00		 je	 $LN933@inflate
  00318	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0031b	8b ce		 mov	 ecx, esi
  0031d	d3 e0		 shl	 eax, cl
  0031f	4b		 dec	 ebx
  00320	03 d0		 add	 edx, eax
  00322	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00325	47		 inc	 edi
  00326	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00329	83 c6 08	 add	 esi, 8
  0032c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0032f	83 fe 20	 cmp	 esi, 32			; 00000020H
  00332	72 dc		 jb	 SHORT $LL47@inflate
  00334	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  00337	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0033a	85 c0		 test	 eax, eax
  0033c	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  0033e	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00341	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00348	74 33		 je	 SHORT $LN53@inflate
  0034a	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0034e	74 2d		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00350	8b c2		 mov	 eax, edx
  00352	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00355	c1 e8 08	 shr	 eax, 8
  00358	88 45 e1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0035b	8b c2		 mov	 eax, edx
  0035d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00360	88 45 e2	 mov	 BYTE PTR _hbuf$[ebp+2], al
  00363	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00366	6a 04		 push	 4
  00368	50		 push	 eax
  00369	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0036c	c1 ea 18	 shr	 edx, 24			; 00000018H
  0036f	88 55 e3	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  00372	e8 00 00 00 00	 call	 _crc32@12
  00377	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0037a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 731  :             INITBITS();

  0037d	33 d2		 xor	 edx, edx

; 732  :             state->mode = OS;

  0037f	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  00386	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00389	33 f6		 xor	 esi, esi

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  0038b	eb 05		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  0038d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00390	73 27		 jae	 SHORT $LN58@inflate
$LL61@inflate:
  00392	85 db		 test	 ebx, ebx
  00394	0f 84 74 02 00
	00		 je	 $LN933@inflate
  0039a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0039d	8b ce		 mov	 ecx, esi
  0039f	d3 e0		 shl	 eax, cl
  003a1	4b		 dec	 ebx
  003a2	03 d0		 add	 edx, eax
  003a4	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  003a7	47		 inc	 edi
  003a8	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  003ab	83 c6 08	 add	 esi, 8
  003ae	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  003b1	83 fe 10	 cmp	 esi, 16			; 00000010H
  003b4	72 dc		 jb	 SHORT $LL61@inflate
  003b6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  003b9	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  003bc	85 f6		 test	 esi, esi
  003be	74 18		 je	 SHORT $LN751@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  003c0	0f b6 c2	 movzx	 eax, dl
  003c3	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  003c6	8b f2		 mov	 esi, edx
  003c8	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  003cb	c1 ee 08	 shr	 esi, 8
  003ce	89 75 c0	 mov	 DWORD PTR $T2[ebp], esi
  003d1	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  003d4	8b c6		 mov	 eax, esi
  003d6	eb 05		 jmp	 SHORT $LN654@inflate
$LN751@inflate:
  003d8	8b c2		 mov	 eax, edx
  003da	c1 e8 08	 shr	 eax, 8
$LN654@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003dd	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003e4	74 20		 je	 SHORT $LN67@inflate
  003e6	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003ea	74 1a		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003ec	88 45 e1	 mov	 BYTE PTR _hbuf$[ebp+1], al
  003ef	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003f2	6a 02		 push	 2
  003f4	50		 push	 eax
  003f5	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003f8	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  003fb	e8 00 00 00 00	 call	 _crc32@12
  00400	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00403	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 741  :             INITBITS();

  00406	33 d2		 xor	 edx, edx

; 742  :             state->mode = EXLEN;

  00408	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  0040f	33 f6		 xor	 esi, esi
  00411	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00414	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00417	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0041e	74 73		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  00420	83 fe 10	 cmp	 esi, 16			; 00000010H
  00423	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00425	85 db		 test	 ebx, ebx
  00427	0f 84 e1 01 00
	00		 je	 $LN933@inflate
  0042d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00430	8b ce		 mov	 ecx, esi
  00432	d3 e0		 shl	 eax, cl
  00434	4b		 dec	 ebx
  00435	03 d0		 add	 edx, eax
  00437	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0043a	47		 inc	 edi
  0043b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0043e	83 c6 08	 add	 esi, 8
  00441	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00444	83 fe 10	 cmp	 esi, 16			; 00000010H
  00447	72 dc		 jb	 SHORT $LL75@inflate
  00449	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  0044c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0044f	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  00452	85 c0		 test	 eax, eax
  00454	74 03		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00456	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00459	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00460	74 23		 je	 SHORT $LN81@inflate
  00462	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00466	74 1d		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00468	6a 02		 push	 2
  0046a	8d 45 e0	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0046d	88 55 e0	 mov	 BYTE PTR _hbuf$[ebp], dl
  00470	50		 push	 eax
  00471	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00474	c1 ea 08	 shr	 edx, 8
  00477	88 55 e1	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0047a	e8 00 00 00 00	 call	 _crc32@12
  0047f	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00482	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 751  :                 INITBITS();

  00485	33 f6		 xor	 esi, esi
  00487	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0048e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 752  :             }

  00491	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  00493	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00496	85 c0		 test	 eax, eax
  00498	74 07		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  0049a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  004a1	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  004a8	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  004ab	89 45 d4	 mov	 DWORD PTR $T12[ebp], eax
  004ae	a9 00 04 00 00	 test	 eax, 1024		; 00000400H
  004b3	0f 84 bb 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  004b9	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 759  :                 if (copy > have) copy = have;
; 760  :                 if (copy) {

  004bc	8b d3		 mov	 edx, ebx
  004be	3b c3		 cmp	 eax, ebx
  004c0	0f 46 d0	 cmovbe	 edx, eax
  004c3	89 55 cc	 mov	 DWORD PTR tv5243[ebp], edx
  004c6	85 d2		 test	 edx, edx
  004c8	0f 84 9e 00 00
	00		 je	 $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  004ce	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004d2	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  004d5	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
  004d8	74 5e		 je	 SHORT $LN372@inflate
  004da	8b 79 24	 mov	 edi, DWORD PTR [ecx+36]
  004dd	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
  004e0	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  004e3	85 db		 test	 ebx, ebx
  004e5	8b 7d d4	 mov	 edi, DWORD PTR $T12[ebp]
  004e8	89 5d c0	 mov	 DWORD PTR tv5542[ebp], ebx
  004eb	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  004ee	89 7d d4	 mov	 DWORD PTR $T12[ebp], edi
  004f1	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  004f4	74 42		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004f6	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  004f9	8b 59 14	 mov	 ebx, DWORD PTR [ecx+20]

; 764  :                         zmemcpy(state->head->extra + len, next,

  004fc	8b 79 18	 mov	 edi, DWORD PTR [ecx+24]
  004ff	2b d8		 sub	 ebx, eax
  00501	8b 45 cc	 mov	 eax, DWORD PTR tv5243[ebp]
  00504	8d 0c 1a	 lea	 ecx, DWORD PTR [edx+ebx]
  00507	8b d7		 mov	 edx, edi
  00509	2b d3		 sub	 edx, ebx
  0050b	3b cf		 cmp	 ecx, edi
  0050d	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00510	0f 47 c2	 cmova	 eax, edx
  00513	50		 push	 eax
  00514	8b 45 c0	 mov	 eax, DWORD PTR tv5542[ebp]
  00517	03 c3		 add	 eax, ebx
  00519	57		 push	 edi
  0051a	50		 push	 eax
  0051b	e8 00 00 00 00	 call	 _memcpy
  00520	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00523	83 c4 0c	 add	 esp, 12			; 0000000cH
  00526	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00529	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0052c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0052f	89 55 d4	 mov	 DWORD PTR $T12[ebp], edx
  00532	8b 55 cc	 mov	 edx, DWORD PTR tv5243[ebp]
  00535	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00538	f7 45 d4 00 02
	00 00		 test	 DWORD PTR $T12[ebp], 512 ; 00000200H
  0053f	74 16		 je	 SHORT $LN373@inflate
  00541	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00545	74 10		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00547	52		 push	 edx
  00548	57		 push	 edi
  00549	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0054c	e8 00 00 00 00	 call	 _crc32@12
  00551	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00554	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00557	8b 55 cc	 mov	 edx, DWORD PTR tv5243[ebp]
  0055a	2b da		 sub	 ebx, edx

; 771  :                     next += copy;
; 772  :                     state->length -= copy;

  0055c	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  0055f	03 fa		 add	 edi, edx
  00561	2b c2		 sub	 eax, edx
  00563	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00566	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00569	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  0056c	85 c0		 test	 eax, eax
  0056e	0f 85 9a 00 00
	00		 jne	 $LN933@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00574	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 777  :             state->mode = NAME;

  0057b	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00582	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  00589	0f 84 08 01 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  0058f	85 db		 test	 ebx, ebx
  00591	74 7b		 je	 SHORT $LN933@inflate

; 781  :                 copy = 0;

  00593	33 d2		 xor	 edx, edx
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00595	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  00598	42		 inc	 edx
  00599	88 45 ff	 mov	 BYTE PTR tv5680[ebp], al

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  0059c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0059f	85 c0		 test	 eax, eax
  005a1	74 23		 je	 SHORT $LN86@inflate
  005a3	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  005a6	89 75 c0	 mov	 DWORD PTR tv5539[ebp], esi
  005a9	85 f6		 test	 esi, esi
  005ab	74 19		 je	 SHORT $LN86@inflate
  005ad	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  005b0	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  005b3	73 11		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  005b5	8a 5d ff	 mov	 bl, BYTE PTR tv5680[ebp]
  005b8	8b c6		 mov	 eax, esi
  005ba	8b 75 c0	 mov	 esi, DWORD PTR tv5539[ebp]
  005bd	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  005c0	ff 41 44	 inc	 DWORD PTR [ecx+68]
  005c3	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  005c6	8a 45 ff	 mov	 al, BYTE PTR tv5680[ebp]
  005c9	84 c0		 test	 al, al
  005cb	74 04		 je	 SHORT $LN380@inflate
  005cd	3b d3		 cmp	 edx, ebx
  005cf	72 c4		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005d1	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  005d8	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  005db	89 55 bc	 mov	 DWORD PTR _copy$1$[ebp], edx
  005de	74 1c		 je	 SHORT $LN381@inflate
  005e0	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  005e4	74 16		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  005e6	52		 push	 edx
  005e7	57		 push	 edi
  005e8	ff 71 1c	 push	 DWORD PTR [ecx+28]
  005eb	e8 00 00 00 00	 call	 _crc32@12
  005f0	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005f3	8b 55 bc	 mov	 edx, DWORD PTR _copy$1$[ebp]
  005f6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005f9	8a 45 ff	 mov	 al, BYTE PTR tv5680[ebp]
$LN381@inflate:

; 791  :                 have -= copy;

  005fc	2b da		 sub	 ebx, edx

; 792  :                 next += copy;

  005fe	03 fa		 add	 edi, edx
  00600	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00603	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 793  :                 if (len) goto inf_leave;

  00606	84 c0		 test	 al, al
  00608	0f 84 97 00 00
	00		 je	 $LN383@inflate
$LN933@inflate:

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  0060e	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN944@inflate:
  00611	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$981:
  00614	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00617	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0061a	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0061d	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  00620	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00623	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  00626	8b 4d ec	 mov	 ecx, DWORD PTR _next$1$[ebp]
  00629	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0062c	8b 45 f8	 mov	 eax, DWORD PTR _hold$1$[ebp]
  0062f	89 0f		 mov	 DWORD PTR [edi], ecx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00631	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  00635	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  00638	8b 75 d8	 mov	 esi, DWORD PTR _out$1$[ebp]
  0063b	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0063e	75 27		 jne	 SHORT $LN502@inflate
  00640	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  00643	0f 84 3d 10 00
	00		 je	 $LN503@inflate
  00649	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0064c	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00651	0f 8d 2f 10 00
	00		 jge	 $LN503@inflate
  00657	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0065c	7c 09		 jl	 SHORT $LN502@inflate
  0065e	83 fa 04	 cmp	 edx, 4
  00661	0f 84 1f 10 00
	00		 je	 $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00667	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0066a	8b c6		 mov	 eax, esi
  0066c	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  0066f	8b cf		 mov	 ecx, edi
  00671	50		 push	 eax
  00672	e8 00 00 00 00	 call	 _updatewindow
  00677	83 c4 04	 add	 esp, 4
  0067a	85 c0		 test	 eax, eax
  0067c	0f 84 04 10 00
	00		 je	 $LN503@inflate

; 1258 :             state->mode = MEM;

  00682	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  00689	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0068a	5e		 pop	 esi
  0068b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00690	5b		 pop	 ebx
  00691	8b e5		 mov	 esp, ebp
  00693	5d		 pop	 ebp
  00694	c2 08 00	 ret	 8
$LN376@inflate:

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  00697	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0069a	85 c0		 test	 eax, eax
  0069c	74 07		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  0069e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 797  :             state->length = 0;

  006a5	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  006ac	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  006b3	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  006ba	0f 84 8b 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  006c0	85 db		 test	 ebx, ebx
  006c2	0f 84 46 ff ff
	ff		 je	 $LN933@inflate

; 802  :                 copy = 0;

  006c8	33 d2		 xor	 edx, edx
  006ca	66 0f 1f 44 00
	00		 npad	 6
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  006d0	8a 04 3a	 mov	 al, BYTE PTR [edx+edi]
  006d3	42		 inc	 edx
  006d4	88 45 ff	 mov	 BYTE PTR tv5679[ebp], al

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  006d7	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006da	85 c0		 test	 eax, eax
  006dc	74 23		 je	 SHORT $LN89@inflate
  006de	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  006e1	89 75 c0	 mov	 DWORD PTR tv5538[ebp], esi
  006e4	85 f6		 test	 esi, esi
  006e6	74 19		 je	 SHORT $LN89@inflate
  006e8	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  006eb	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  006ee	73 11		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  006f0	8a 5d ff	 mov	 bl, BYTE PTR tv5679[ebp]
  006f3	8b c6		 mov	 eax, esi
  006f5	8b 75 c0	 mov	 esi, DWORD PTR tv5538[ebp]
  006f8	88 1c 30	 mov	 BYTE PTR [eax+esi], bl
  006fb	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006fe	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  00701	8a 45 ff	 mov	 al, BYTE PTR tv5679[ebp]
  00704	84 c0		 test	 al, al
  00706	74 04		 je	 SHORT $LN389@inflate
  00708	3b d3		 cmp	 edx, ebx
  0070a	72 c4		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  0070c	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00713	8b 75 e8	 mov	 esi, DWORD PTR _bits$1$[ebp]
  00716	89 55 bc	 mov	 DWORD PTR _copy$2$[ebp], edx
  00719	74 1c		 je	 SHORT $LN390@inflate
  0071b	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  0071f	74 16		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00721	52		 push	 edx
  00722	57		 push	 edi
  00723	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00726	e8 00 00 00 00	 call	 _crc32@12
  0072b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0072e	8b 55 bc	 mov	 edx, DWORD PTR _copy$2$[ebp]
  00731	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00734	8a 45 ff	 mov	 al, BYTE PTR tv5679[ebp]
$LN390@inflate:

; 812  :                 have -= copy;

  00737	2b da		 sub	 ebx, edx

; 813  :                 next += copy;

  00739	03 fa		 add	 edi, edx
  0073b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0073e	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi

; 814  :                 if (len) goto inf_leave;

  00741	84 c0		 test	 al, al
  00743	0f 85 c5 fe ff
	ff		 jne	 $LN933@inflate

; 815  :             }

  00749	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  0074b	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0074e	85 c0		 test	 eax, eax
  00750	74 07		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  00752	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  00759	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 818  :             state->mode = HCRC;

  0075c	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00763	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00766	89 45 bc	 mov	 DWORD PTR tv5255[ebp], eax
  00769	a9 00 02 00 00	 test	 eax, 512		; 00000200H
  0076e	74 5f		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  00770	83 fe 10	 cmp	 esi, 16			; 00000010H
  00773	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00775	85 db		 test	 ebx, ebx
  00777	0f 84 91 fe ff
	ff		 je	 $LN933@inflate
  0077d	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00780	8b ce		 mov	 ecx, esi
  00782	d3 e0		 shl	 eax, cl
  00784	83 c6 08	 add	 esi, 8
  00787	4b		 dec	 ebx
  00788	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  0078b	03 d0		 add	 edx, eax
  0078d	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00790	47		 inc	 edi
  00791	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00794	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00797	83 fe 10	 cmp	 esi, 16			; 00000010H
  0079a	72 d9		 jb	 SHORT $LL95@inflate
  0079c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0079f	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  007a3	74 1e		 je	 SHORT $LN102@inflate
  007a5	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  007a9	3b d0		 cmp	 edx, eax
  007ab	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  007ad	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  007b0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  007b7	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  007be	e9 cb 09 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 824  :                     state->mode = BAD;
; 825  :                     break;
; 826  :                 }
; 827  :                 INITBITS();

  007c3	33 f6		 xor	 esi, esi
  007c5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  007cc	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  007cf	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  007d2	85 c0		 test	 eax, eax
  007d4	74 16		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  007d6	8b 55 bc	 mov	 edx, DWORD PTR tv5255[ebp]
  007d9	c1 fa 09	 sar	 edx, 9
  007dc	83 e2 01	 and	 edx, 1
  007df	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 831  :                 state->head->done = 1;

  007e2	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  007e5	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  007ec	6a 00		 push	 0
  007ee	6a 00		 push	 0
  007f0	6a 00		 push	 0
  007f2	e8 00 00 00 00	 call	 _crc32@12
  007f7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007fa	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007fd	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00800	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 834  :             state->mode = TYPE;
; 835  :             break;

  00803	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00806	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  0080d	e9 7c 09 00 00	 jmp	 $LN8@inflate
$LN105@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00812	83 fe 20	 cmp	 esi, 32			; 00000020H
  00815	73 24		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  00817	85 db		 test	 ebx, ebx
  00819	0f 84 ef fd ff
	ff		 je	 $LN933@inflate
  0081f	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00822	8b ce		 mov	 ecx, esi
  00824	d3 e0		 shl	 eax, cl
  00826	4b		 dec	 ebx
  00827	03 d0		 add	 edx, eax
  00829	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0082c	47		 inc	 edi
  0082d	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00830	83 c6 08	 add	 esi, 8
  00833	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00836	83 fe 20	 cmp	 esi, 32			; 00000020H
  00839	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  0083b	8b ca		 mov	 ecx, edx
  0083d	8b c2		 mov	 eax, edx
  0083f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00842	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00848	03 c8		 add	 ecx, eax
  0084a	8b c2		 mov	 eax, edx
  0084c	c1 e8 08	 shr	 eax, 8
  0084f	c1 e1 08	 shl	 ecx, 8
  00852	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00857	c1 ea 18	 shr	 edx, 24			; 00000018H
  0085a	03 c1		 add	 eax, ecx
  0085c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0085f	03 c2		 add	 eax, edx
  00861	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00864	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00867	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 840  :             INITBITS();

  0086a	33 d2		 xor	 edx, edx
  0086c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0086f	33 f6		 xor	 esi, esi

; 841  :             state->mode = DICT;

  00871	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00878	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0087c	0f 84 a9 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00882	6a 00		 push	 0
  00884	6a 00		 push	 0
  00886	6a 00		 push	 0
  00888	e8 00 00 00 00	 call	 _adler32@12
  0088d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00890	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00893	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00896	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00899	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 848  :             state->mode = TYPE;

  0089c	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  008a3	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  008a6	83 f8 05	 cmp	 eax, 5
  008a9	0f 84 5f fd ff
	ff		 je	 $LN933@inflate
  008af	83 f8 06	 cmp	 eax, 6
  008b2	0f 84 56 fd ff
	ff		 je	 $LN933@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  008b8	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  008bc	74 1e		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  008be	8b ce		 mov	 ecx, esi
  008c0	83 e1 07	 and	 ecx, 7
  008c3	d3 ea		 shr	 edx, cl
  008c5	2b f1		 sub	 esi, ecx

; 854  :                 state->mode = CHECK;

  008c7	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  008ca	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008cd	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  008d0	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 855  :                 break;

  008d7	e9 b2 08 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  008dc	83 fe 03	 cmp	 esi, 3
  008df	73 27		 jae	 SHORT $LN120@inflate
$LL123@inflate:
  008e1	85 db		 test	 ebx, ebx
  008e3	0f 84 25 fd ff
	ff		 je	 $LN933@inflate
  008e9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  008ec	8b ce		 mov	 ecx, esi
  008ee	d3 e0		 shl	 eax, cl
  008f0	4b		 dec	 ebx
  008f1	03 d0		 add	 edx, eax
  008f3	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  008f6	47		 inc	 edi
  008f7	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  008fa	83 c6 08	 add	 esi, 8
  008fd	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00900	83 fe 03	 cmp	 esi, 3
  00903	72 dc		 jb	 SHORT $LL123@inflate
  00905	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 858  :             state->last = BITS(1);

  00908	8b c2		 mov	 eax, edx

; 859  :             DROPBITS(1);

  0090a	d1 ea		 shr	 edx, 1
  0090c	83 e0 01	 and	 eax, 1
  0090f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 860  :             switch (BITS(2)) {

  00912	8b c2		 mov	 eax, edx
  00914	83 e0 03	 and	 eax, 3
  00917	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN816@inflate[eax*4]
$LN408@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0091e	c1 ea 02	 shr	 edx, 2
  00921	83 ee 03	 sub	 esi, 3
  00924	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  0092b	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0092e	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  00931	e9 58 08 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  00936	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  0093b	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  0093f	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00946	75 37		 jne	 SHORT $LN138@inflate

; 872  :                     DROPBITS(2);

  00948	c1 ea 02	 shr	 edx, 2
  0094b	83 ee 03	 sub	 esi, 3
  0094e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;
; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  00951	e9 b8 fc ff ff	 jmp	 $LN933@inflate
$LN411@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00956	c1 ea 02	 shr	 edx, 2
  00959	83 ee 03	 sub	 esi, 3
  0095c	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00963	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00966	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  00969	e9 20 08 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 873  :                     goto inf_leave;
; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  0096e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00971	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 883  :                 state->mode = BAD;

  00978	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0097f	c1 ea 02	 shr	 edx, 2
  00982	83 ee 03	 sub	 esi, 3
  00985	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00988	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  0098b	e9 fe 07 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00990	8b ce		 mov	 ecx, esi
  00992	83 e1 07	 and	 ecx, 7
  00995	2b f1		 sub	 esi, ecx
  00997	d3 ea		 shr	 edx, cl
  00999	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0099c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 889  :             NEEDBITS(32);

  0099f	83 fe 20	 cmp	 esi, 32			; 00000020H
  009a2	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  009a4	85 db		 test	 ebx, ebx
  009a6	0f 84 62 fc ff
	ff		 je	 $LN933@inflate
  009ac	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  009af	8b ce		 mov	 ecx, esi
  009b1	d3 e0		 shl	 eax, cl
  009b3	83 c6 08	 add	 esi, 8
  009b6	4b		 dec	 ebx
  009b7	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  009ba	03 d0		 add	 edx, eax
  009bc	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  009bf	47		 inc	 edi
  009c0	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  009c3	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  009c6	83 fe 20	 cmp	 esi, 32			; 00000020H
  009c9	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009cb	8b c2		 mov	 eax, edx
  009cd	0f b7 ca	 movzx	 ecx, dx
  009d0	f7 d0		 not	 eax
  009d2	89 4d bc	 mov	 DWORD PTR tv5536[ebp], ecx
  009d5	c1 e8 10	 shr	 eax, 16			; 00000010H
  009d8	3b c8		 cmp	 ecx, eax
  009da	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  009dd	74 16		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  009df	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  009e2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  009e9	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  009f0	e9 99 07 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 892  :                 state->mode = BAD;
; 893  :                 break;
; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  009f5	8b 45 bc	 mov	 eax, DWORD PTR tv5536[ebp]

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  009f8	33 d2		 xor	 edx, edx
  009fa	33 f6		 xor	 esi, esi
  009fc	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  009ff	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00a03	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a06	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a09	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  00a10	0f 84 f8 fb ff
	ff		 je	 $LN933@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00a16	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  00a1d	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  00a20	89 45 bc	 mov	 DWORD PTR _copy$3$[ebp], eax

; 905  :             if (copy) {

  00a23	85 c0		 test	 eax, eax
  00a25	74 4a		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;
; 907  :                 if (copy > left) copy = left;

  00a27	39 5d bc	 cmp	 DWORD PTR _copy$3$[ebp], ebx
  00a2a	8b c3		 mov	 eax, ebx

; 908  :                 if (copy == 0) goto inf_leave;

  00a2c	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00a2f	0f 46 45 bc	 cmovbe	 eax, DWORD PTR _copy$3$[ebp]
  00a33	3b c1		 cmp	 eax, ecx
  00a35	0f 46 c8	 cmovbe	 ecx, eax
  00a38	89 4d bc	 mov	 DWORD PTR tv5677[ebp], ecx
  00a3b	85 c9		 test	 ecx, ecx
  00a3d	0f 84 cb fb ff
	ff		 je	 $LN933@inflate

; 909  :                 zmemcpy(put, next, copy);

  00a43	51		 push	 ecx
  00a44	57		 push	 edi
  00a45	ff 75 dc	 push	 DWORD PTR _put$1$[ebp]
  00a48	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  00a4d	8b 45 bc	 mov	 eax, DWORD PTR tv5677[ebp]
  00a50	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  :                 next += copy;
; 912  :                 left -= copy;
; 913  :                 put += copy;
; 914  :                 state->length -= copy;

  00a53	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a56	2b d8		 sub	 ebx, eax
  00a58	29 45 e4	 sub	 DWORD PTR _left$1$[ebp], eax
  00a5b	03 f8		 add	 edi, eax
  00a5d	01 45 dc	 add	 DWORD PTR _put$1$[ebp], eax

; 915  :                 break;

  00a60	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00a63	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a66	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a69	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00a6c	e9 1d 07 00 00	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  00a71	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 919  :             break;

  00a78	e9 11 07 00 00	 jmp	 $LN8@inflate
$LN155@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a7d	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a80	73 24		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a82	85 db		 test	 ebx, ebx
  00a84	0f 84 84 fb ff
	ff		 je	 $LN933@inflate
  00a8a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a8d	8b ce		 mov	 ecx, esi
  00a8f	d3 e0		 shl	 eax, cl
  00a91	4b		 dec	 ebx
  00a92	03 d0		 add	 edx, eax
  00a94	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a97	47		 inc	 edi
  00a98	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a9b	83 c6 08	 add	 esi, 8
  00a9e	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00aa1	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00aa4	72 dc		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00aa6	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00aa9	8b ca		 mov	 ecx, edx

; 923  :             DROPBITS(5);

  00aab	c1 ea 05	 shr	 edx, 5
  00aae	83 e1 1f	 and	 ecx, 31			; 0000001fH

; 924  :             state->ndist = BITS(5) + 1;

  00ab1	8b fa		 mov	 edi, edx
  00ab3	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00ab9	83 e7 1f	 and	 edi, 31			; 0000001fH

; 925  :             DROPBITS(5);

  00abc	c1 ea 05	 shr	 edx, 5
  00abf	47		 inc	 edi
  00ac0	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00ac3	89 78 68	 mov	 DWORD PTR [eax+104], edi

; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00ac6	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00ac9	89 7d bc	 mov	 DWORD PTR tv5708[ebp], edi
  00acc	8b c2		 mov	 eax, edx
  00ace	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00ad1	83 e0 0f	 and	 eax, 15			; 0000000fH
  00ad4	83 c0 04	 add	 eax, 4
  00ad7	c1 ea 04	 shr	 edx, 4
  00ada	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00add	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00ae0	89 47 60	 mov	 DWORD PTR [edi+96], eax

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00ae3	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00ae6	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00aec	0f 87 01 01 00
	00		 ja	 $LN426@inflate
  00af2	83 7d bc 1e	 cmp	 DWORD PTR tv5708[ebp], 30 ; 0000001eH
  00af6	0f 87 f7 00 00
	00		 ja	 $LN426@inflate

; 932  :                 break;
; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00afc	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00aff	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = LENLENS;

  00b06	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00b0d	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b10	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00b13	73 66		 jae	 SHORT $LN534@inflate
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00b15	83 fe 03	 cmp	 esi, 3
  00b18	73 2a		 jae	 SHORT $LN172@inflate
  00b1a	66 0f 1f 44 00
	00		 npad	 6
$LL175@inflate:
  00b20	85 db		 test	 ebx, ebx
  00b22	0f 84 e6 fa ff
	ff		 je	 $LN933@inflate
  00b28	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00b2b	8b ce		 mov	 ecx, esi
  00b2d	d3 e0		 shl	 eax, cl
  00b2f	4b		 dec	 ebx
  00b30	03 d0		 add	 edx, eax
  00b32	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00b35	47		 inc	 edi
  00b36	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00b39	83 c6 08	 add	 esi, 8
  00b3c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00b3f	83 fe 03	 cmp	 esi, 3
  00b42	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b44	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00b47	8b ca		 mov	 ecx, edx
  00b49	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00b4c	83 e1 07	 and	 ecx, 7

; 942  :                 DROPBITS(3);

  00b4f	c1 ea 03	 shr	 edx, 3
  00b52	83 ee 03	 sub	 esi, 3
  00b55	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00b58	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00b5b	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00b5e	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b66	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00b6b	8b cf		 mov	 ecx, edi
  00b6d	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b70	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b73	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b76	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00b79	72 9a		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00b7b	83 f8 13	 cmp	 eax, 19			; 00000013H
  00b7e	73 1b		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b80	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b83	33 d2		 xor	 edx, edx
  00b85	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b8d	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b92	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b95	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b99	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  00b9b	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]

; 947  :             state->lencode = (const code FAR *)(state->next);
; 948  :             state->lenbits = 7;

  00ba1	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7
  00ba8	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]
  00bab	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00bae	89 02		 mov	 DWORD PTR [edx], eax
  00bb0	83 c1 58	 add	 ecx, 88			; 00000058H

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00bb3	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bb6	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00bbb	50		 push	 eax
  00bbc	51		 push	 ecx
  00bbd	52		 push	 edx
  00bbe	8b 55 f4	 mov	 edx, DWORD PTR _state$1$[ebp]
  00bc1	33 c9		 xor	 ecx, ecx
  00bc3	6a 13		 push	 19			; 00000013H
  00bc5	8d 52 74	 lea	 edx, DWORD PTR [edx+116]
  00bc8	e8 00 00 00 00	 call	 _inflate_table

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  00bcd	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00bd0	83 c4 10	 add	 esp, 16			; 00000010H
  00bd3	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00bd6	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00bd9	85 c0		 test	 eax, eax
  00bdb	74 2f		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00bdd	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00be0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00be7	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00bee	e9 9b 05 00 00	 jmp	 $LN8@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00bf3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 931  :                 state->mode = BAD;

  00bf6	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00bf9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c00	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00c07	e9 82 05 00 00	 jmp	 $LN8@inflate
$LN429@inflate:

; 953  :                 state->mode = BAD;
; 954  :                 break;
; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00c0c	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  00c13	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
  00c1a	c7 45 d4 46 3f
	00 00		 mov	 DWORD PTR $T11[ebp], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00c21	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00c24	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00c27	39 41 6c	 cmp	 DWORD PTR [ecx+108], eax
  00c2a	0f 83 57 02 00
	00		 jae	 $LN939@inflate
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00c30	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00c33	b8 01 00 00 00	 mov	 eax, 1
  00c38	d3 e0		 shl	 eax, cl
  00c3a	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00c3d	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00c40	89 4d bc	 mov	 DWORD PTR tv5532[ebp], ecx
  00c43	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00c46	89 45 c0	 mov	 DWORD PTR tv5581[ebp], eax
  00c49	8b c1		 mov	 eax, ecx
  00c4b	8b 4d c0	 mov	 ecx, DWORD PTR tv5581[ebp]
  00c4e	23 c2		 and	 eax, edx
  00c50	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c53	8b c8		 mov	 ecx, eax
  00c55	c1 e9 08	 shr	 ecx, 8
  00c58	89 4d e8	 mov	 DWORD PTR $T13[ebp], ecx
  00c5b	89 45 d4	 mov	 DWORD PTR $T10[ebp], eax
  00c5e	c1 6d d4 10	 shr	 DWORD PTR $T10[ebp], 16	; 00000010H
  00c62	0f b6 c9	 movzx	 ecx, cl

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00c65	3b ce		 cmp	 ecx, esi
  00c67	76 47		 jbe	 SHORT $LN655@inflate
  00c69	0f 1f 80 00 00
	00 00		 npad	 7
$LL187@inflate:

; 964  :                     PULLBYTE();

  00c70	85 db		 test	 ebx, ebx
  00c72	0f 84 96 f9 ff
	ff		 je	 $LN933@inflate
  00c78	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c7b	8b ce		 mov	 ecx, esi
  00c7d	d3 e0		 shl	 eax, cl
  00c7f	4b		 dec	 ebx
  00c80	8b 4d c0	 mov	 ecx, DWORD PTR tv5581[ebp]
  00c83	03 d0		 add	 edx, eax
  00c85	8b 45 bc	 mov	 eax, DWORD PTR tv5532[ebp]
  00c88	47		 inc	 edi
  00c89	23 c2		 and	 eax, edx
  00c8b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c8e	83 c6 08	 add	 esi, 8
  00c91	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00c94	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00c97	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00c9a	8b c8		 mov	 ecx, eax
  00c9c	c1 e9 08	 shr	 ecx, 8
  00c9f	89 4d e8	 mov	 DWORD PTR $T13[ebp], ecx
  00ca2	89 45 d4	 mov	 DWORD PTR $T10[ebp], eax
  00ca5	c1 6d d4 10	 shr	 DWORD PTR $T10[ebp], 16	; 00000010H
  00ca9	0f b6 c9	 movzx	 ecx, cl
  00cac	3b ce		 cmp	 ecx, esi
  00cae	77 c0		 ja	 SHORT $LL187@inflate
$LN655@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00cb0	8b 4d d4	 mov	 ecx, DWORD PTR $T10[ebp]
  00cb3	0f b7 c9	 movzx	 ecx, cx
  00cb6	89 4d bc	 mov	 DWORD PTR tv5508[ebp], ecx
  00cb9	0f b7 c9	 movzx	 ecx, cx
  00cbc	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00cbf	8b 4d e8	 mov	 ecx, DWORD PTR $T13[ebp]
  00cc2	0f b6 c9	 movzx	 ecx, cl
  00cc5	73 2b		 jae	 SHORT $LN433@inflate

; 967  :                     DROPBITS(here.bits);
; 968  :                     state->lens[state->have++] = here.val;

  00cc7	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00cca	2b f1		 sub	 esi, ecx
  00ccc	d3 ea		 shr	 edx, cl
  00cce	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cd1	c1 e8 10	 shr	 eax, 16			; 00000010H
  00cd4	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cd7	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cda	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00cdd	66 89 44 4f 74	 mov	 WORD PTR [edi+ecx*2+116], ax
  00ce2	8b cf		 mov	 ecx, edi
  00ce4	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00ce7	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00cea	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 969  :                 }

  00ced	e9 62 01 00 00	 jmp	 $LN973@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00cf2	75 6c		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00cf4	83 c1 02	 add	 ecx, 2
  00cf7	89 4d bc	 mov	 DWORD PTR tv5574[ebp], ecx
  00cfa	3b f1		 cmp	 esi, ecx
  00cfc	73 27		 jae	 SHORT $LN196@inflate
  00cfe	66 90		 npad	 2
$LL199@inflate:
  00d00	85 db		 test	 ebx, ebx
  00d02	0f 84 06 f9 ff
	ff		 je	 $LN933@inflate
  00d08	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d0b	8b ce		 mov	 ecx, esi
  00d0d	d3 e2		 shl	 edx, cl
  00d0f	4b		 dec	 ebx
  00d10	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d13	47		 inc	 edi
  00d14	83 c6 08	 add	 esi, 8
  00d17	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d1a	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d1d	3b 75 bc	 cmp	 esi, DWORD PTR tv5574[ebp]
  00d20	72 de		 jb	 SHORT $LL199@inflate
  00d22	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00d25	0f b6 cc	 movzx	 ecx, ah
  00d28	d3 ea		 shr	 edx, cl
  00d2a	2b f1		 sub	 esi, ecx

; 974  :                         if (state->have == 0) {

  00d2c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00d2f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d32	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00d35	83 79 6c 00	 cmp	 DWORD PTR [ecx+108], 0
  00d39	0f 84 32 01 00
	00		 je	 $LN567@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";
; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];
; 980  :                         copy = 3 + BITS(2);
; 981  :                         DROPBITS(2);

  00d3f	8b 79 6c	 mov	 edi, DWORD PTR [ecx+108]
  00d42	8b c2		 mov	 eax, edx
  00d44	83 e0 03	 and	 eax, 3
  00d47	c1 ea 02	 shr	 edx, 2
  00d4a	83 c0 03	 add	 eax, 3
  00d4d	83 ee 02	 sub	 esi, 2
  00d50	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00d53	0f b7 7c 79 72	 movzx	 edi, WORD PTR [ecx+edi*2+114]
  00d58	89 7d c8	 mov	 DWORD PTR $T9[ebp], edi

; 982  :                     }

  00d5b	e9 ae 00 00 00	 jmp	 $LN974@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00d60	66 83 7d bc 11	 cmp	 WORD PTR tv5508[ebp], 17 ; 00000011H
  00d65	75 49		 jne	 SHORT $LN226@inflate

; 984  :                         NEEDBITS(here.bits + 3);

  00d67	83 c1 03	 add	 ecx, 3
  00d6a	89 4d bc	 mov	 DWORD PTR tv5525[ebp], ecx
  00d6d	3b f1		 cmp	 esi, ecx
  00d6f	73 25		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d71	85 db		 test	 ebx, ebx
  00d73	0f 84 95 f8 ff
	ff		 je	 $LN933@inflate
  00d79	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00d7c	8b ce		 mov	 ecx, esi
  00d7e	d3 e2		 shl	 edx, cl
  00d80	4b		 dec	 ebx
  00d81	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00d84	47		 inc	 edi
  00d85	83 c6 08	 add	 esi, 8
  00d88	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d8b	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00d8e	3b 75 bc	 cmp	 esi, DWORD PTR tv5525[ebp]
  00d91	72 de		 jb	 SHORT $LL213@inflate
  00d93	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00d96	0f b6 cc	 movzx	 ecx, ah
  00d99	d3 ea		 shr	 edx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);

  00d9b	8b c2		 mov	 eax, edx
  00d9d	83 e0 07	 and	 eax, 7
  00da0	83 c0 03	 add	 eax, 3

; 988  :                         DROPBITS(3);

  00da3	c1 ea 03	 shr	 edx, 3
  00da6	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00da9	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 989  :                     }

  00dae	eb 4d		 jmp	 SHORT $LN975@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00db0	83 c1 07	 add	 ecx, 7
  00db3	89 4d bc	 mov	 DWORD PTR tv5524[ebp], ecx
  00db6	3b f1		 cmp	 esi, ecx
  00db8	73 2b		 jae	 SHORT $LN224@inflate
  00dba	66 0f 1f 44 00
	00		 npad	 6
$LL227@inflate:
  00dc0	85 db		 test	 ebx, ebx
  00dc2	0f 84 46 f8 ff
	ff		 je	 $LN933@inflate
  00dc8	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00dcb	8b ce		 mov	 ecx, esi
  00dcd	d3 e2		 shl	 edx, cl
  00dcf	4b		 dec	 ebx
  00dd0	01 55 f8	 add	 DWORD PTR _hold$1$[ebp], edx
  00dd3	47		 inc	 edi
  00dd4	83 c6 08	 add	 esi, 8
  00dd7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  00dda	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00ddd	3b 75 bc	 cmp	 esi, DWORD PTR tv5524[ebp]
  00de0	72 de		 jb	 SHORT $LL227@inflate
  00de2	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00de5	0f b6 cc	 movzx	 ecx, ah
  00de8	d3 ea		 shr	 edx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);

  00dea	8b c2		 mov	 eax, edx
  00dec	83 e0 7f	 and	 eax, 127		; 0000007fH
  00def	83 c0 0b	 add	 eax, 11			; 0000000bH

; 995  :                         DROPBITS(7);

  00df2	c1 ea 07	 shr	 edx, 7
  00df5	89 45 d4	 mov	 DWORD PTR _copy$4$[ebp], eax
  00df8	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
$LN975@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00dfd	2b c1		 sub	 eax, ecx
  00dff	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], 0
  00e06	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e09	03 f0		 add	 esi, eax
  00e0b	8b 45 d4	 mov	 eax, DWORD PTR _copy$4$[ebp]
$LN974@inflate:
  00e0e	8b 49 6c	 mov	 ecx, DWORD PTR [ecx+108]
  00e11	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  00e14	03 c8		 add	 ecx, eax
  00e16	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  00e19	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00e1c	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00e1f	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00e22	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00e25	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e28	3b c8		 cmp	 ecx, eax
  00e2a	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e2d	77 42		 ja	 SHORT $LN567@inflate
  00e2f	8b 5d d4	 mov	 ebx, DWORD PTR _copy$4$[ebp]
  00e32	8b 55 c8	 mov	 edx, DWORD PTR $T9[ebp]
$LL238@inflate:

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)
; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00e35	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00e38	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00e3d	8b 79 6c	 mov	 edi, DWORD PTR [ecx+108]
  00e40	8d 7f 01	 lea	 edi, DWORD PTR [edi+1]
  00e43	89 7d c8	 mov	 DWORD PTR $T5[ebp], edi
  00e46	89 79 6c	 mov	 DWORD PTR [ecx+108], edi
  00e49	83 eb 01	 sub	 ebx, 1
  00e4c	75 e7		 jne	 SHORT $LL238@inflate
  00e4e	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  00e51	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN973@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00e54	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00e57	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00e5a	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
  00e5d	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00e60	03 45 c0	 add	 eax, DWORD PTR $T3[ebp]
  00e63	39 45 c8	 cmp	 DWORD PTR $T5[ebp], eax
  00e66	0f 82 c4 fd ff
	ff		 jb	 $LL185@inflate

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  00e6c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00e6f	eb 19		 jmp	 SHORT $LN186@inflate
$LN567@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00e71	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e74	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e7b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e82	e9 07 03 00 00	 jmp	 $LN8@inflate
$LN939@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00e87	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00e8a	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00e8f	0f 84 f9 02 00
	00		 je	 $LN8@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00e95	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00e9d	75 16		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e9f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ea2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00ea9	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00eb0	e9 d9 02 00 00	 jmp	 $LN8@inflate
$LN445@inflate:

; 1013 :                 state->mode = BAD;
; 1014 :                 break;
; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00eb5	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00eb8	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00ebf	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00ec5	89 55 bc	 mov	 DWORD PTR tv5588[ebp], edx

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00ec8	8d b9 f4 02 00
	00		 lea	 edi, DWORD PTR [ecx+756]
  00ece	89 02		 mov	 DWORD PTR [edx], eax
  00ed0	89 41 50	 mov	 DWORD PTR [ecx+80], eax
  00ed3	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00ed6	57		 push	 edi
  00ed7	50		 push	 eax
  00ed8	52		 push	 edx
  00ed9	ff 71 64	 push	 DWORD PTR [ecx+100]
  00edc	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00edf	89 7d c0	 mov	 DWORD PTR tv5583[ebp], edi
  00ee2	b9 01 00 00 00	 mov	 ecx, 1
  00ee7	e8 00 00 00 00	 call	 _inflate_table

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  00eec	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00eef	83 c4 10	 add	 esp, 16			; 00000010H
  00ef2	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00ef5	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00ef8	85 c0		 test	 eax, eax
  00efa	74 19		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00efc	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1027 :                 state->mode = BAD;
; 1028 :                 break;

  00eff	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00f02	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00f09	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00f10	e9 79 02 00 00	 jmp	 $LN8@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00f15	8b 55 bc	 mov	 edx, DWORD PTR tv5588[ebp]

; 1031 :             state->distbits = 6;
; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f18	ff 75 c0	 push	 DWORD PTR tv5583[ebp]
  00f1b	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00f22	8b 02		 mov	 eax, DWORD PTR [edx]
  00f24	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00f27	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00f2a	50		 push	 eax
  00f2b	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00f2e	52		 push	 edx
  00f2f	ff 71 68	 push	 DWORD PTR [ecx+104]
  00f32	83 c1 74	 add	 ecx, 116		; 00000074H
  00f35	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00f38	b9 02 00 00 00	 mov	 ecx, 2
  00f3d	e8 00 00 00 00	 call	 _inflate_table

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  00f42	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f45	83 c4 10	 add	 esp, 16			; 00000010H
  00f48	89 45 d0	 mov	 DWORD PTR _ret$1$[ebp], eax
  00f4b	85 c0		 test	 eax, eax
  00f4d	74 19		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  00f4f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1036 :                 state->mode = BAD;
; 1037 :                 break;

  00f52	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00f55	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00f5c	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00f63	e9 26 02 00 00	 jmp	 $LN8@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00f68	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00f6b	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00f72	83 fa 06	 cmp	 edx, 6
  00f75	0f 84 03 07 00
	00		 je	 $LN909@inflate
  00f7b	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00f7e	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00f85	83 fb 06	 cmp	 ebx, 6
  00f88	0f 82 75 00 00
	00		 jb	 $LN451@inflate
  00f8e	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00f95	72 6c		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00f97	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f9a	8b 7d dc	 mov	 edi, DWORD PTR _put$1$[ebp]
  00f9d	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00fa0	8b 7d e4	 mov	 edi, DWORD PTR _left$1$[ebp]
  00fa3	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00fa6	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  00fa9	89 38		 mov	 DWORD PTR [eax], edi
  00fab	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00fae	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 1047 :                 inflate_fast(strm, out);

  00fb1	8b 55 d8	 mov	 edx, DWORD PTR _out$1$[ebp]
  00fb4	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00fb7	8b c8		 mov	 ecx, eax
  00fb9	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00fbe	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00fc1	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00fc4	8b 38		 mov	 edi, DWORD PTR [eax]
  00fc6	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00fc9	89 4d dc	 mov	 DWORD PTR _put$1$[ebp], ecx
  00fcc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00fcf	89 4d e4	 mov	 DWORD PTR _left$1$[ebp], ecx
  00fd2	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00fd5	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  00fd8	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1049 :                 if (state->mode == TYPE)

  00fdb	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00fe2	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00fe5	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00fe8	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  00feb	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  00fee	0f 85 9a 01 00
	00		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00ff4	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1051 :                 break;

  00ffe	e9 8b 01 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  01003	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  0100d	b8 01 00 00 00	 mov	 eax, 1
  01012	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  01015	d3 e0		 shl	 eax, cl
  01017	48		 dec	 eax
  01018	89 45 c0	 mov	 DWORD PTR tv5531[ebp], eax
  0101b	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  0101e	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  01021	8b 45 c0	 mov	 eax, DWORD PTR tv5531[ebp]
  01024	23 c2		 and	 eax, edx
  01026	89 4d c8	 mov	 DWORD PTR tv5580[ebp], ecx
  01029	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0102c	8b c8		 mov	 ecx, eax
  0102e	c1 e9 08	 shr	 ecx, 8
  01031	0f b6 c9	 movzx	 ecx, cl

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  01034	3b ce		 cmp	 ecx, esi
  01036	76 36		 jbe	 SHORT $LN569@inflate
$LL246@inflate:

; 1057 :                 PULLBYTE();

  01038	85 db		 test	 ebx, ebx
  0103a	0f 84 ce f5 ff
	ff		 je	 $LN933@inflate
  01040	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01043	8b ce		 mov	 ecx, esi
  01045	d3 e0		 shl	 eax, cl
  01047	4b		 dec	 ebx
  01048	8b 4d c8	 mov	 ecx, DWORD PTR tv5580[ebp]
  0104b	03 d0		 add	 edx, eax
  0104d	8b 45 c0	 mov	 eax, DWORD PTR tv5531[ebp]
  01050	47		 inc	 edi
  01051	23 c2		 and	 eax, edx
  01053	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  01056	83 c6 08	 add	 esi, 8
  01059	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0105c	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  0105f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  01062	8b c8		 mov	 ecx, eax
  01064	c1 e9 08	 shr	 ecx, 8
  01067	0f b6 c9	 movzx	 ecx, cl
  0106a	3b ce		 cmp	 ecx, esi
  0106c	77 ca		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  0106e	84 c0		 test	 al, al
  01070	0f 84 b6 00 00
	00		 je	 $LN937@inflate
  01076	a8 f0		 test	 al, 240			; 000000f0H
  01078	0f 85 ae 00 00
	00		 jne	 $LN937@inflate

; 1060 :                 last = here;

  0107e	8b c8		 mov	 ecx, eax

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  01080	bf 01 00 00 00	 mov	 edi, 1
  01085	c1 e9 08	 shr	 ecx, 8
  01088	8b d0		 mov	 edx, eax
  0108a	0f b6 d9	 movzx	 ebx, cl
  0108d	0f b6 c8	 movzx	 ecx, al
  01090	03 cb		 add	 ecx, ebx
  01092	c1 e8 10	 shr	 eax, 16			; 00000010H
  01095	d3 e7		 shl	 edi, cl
  01097	8b cb		 mov	 ecx, ebx
  01099	4f		 dec	 edi
  0109a	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  0109d	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  010a0	d3 ef		 shr	 edi, cl
  010a2	8b 4d c8	 mov	 ecx, DWORD PTR tv5580[ebp]
  010a5	03 f8		 add	 edi, eax
  010a7	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  010aa	8b c8		 mov	 ecx, eax
  010ac	c1 e9 08	 shr	 ecx, 8

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  010af	0f b6 c9	 movzx	 ecx, cl
  010b2	03 cb		 add	 ecx, ebx
  010b4	3b ce		 cmp	 ecx, esi
  010b6	76 5c		 jbe	 SHORT $LN260@inflate
  010b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL252@inflate:

; 1065 :                     PULLBYTE();

  010c0	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  010c3	85 c0		 test	 eax, eax
  010c5	0f 84 46 f5 ff
	ff		 je	 $LN944@inflate
  010cb	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  010ce	48		 dec	 eax
  010cf	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  010d2	8b ce		 mov	 ecx, esi
  010d4	bf 01 00 00 00	 mov	 edi, 1
  010d9	83 c6 08	 add	 esi, 8
  010dc	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  010df	43		 inc	 ebx
  010e0	d3 e0		 shl	 eax, cl
  010e2	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  010e5	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  010e9	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  010ec	0f b6 de	 movzx	 ebx, dh
  010ef	0f b6 ca	 movzx	 ecx, dl
  010f2	03 cb		 add	 ecx, ebx
  010f4	d3 e7		 shl	 edi, cl
  010f6	8b cb		 mov	 ecx, ebx
  010f8	4f		 dec	 edi
  010f9	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  010fc	d3 ef		 shr	 edi, cl
  010fe	03 f8		 add	 edi, eax
  01100	8b 45 c8	 mov	 eax, DWORD PTR tv5580[ebp]
  01103	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01106	8b c8		 mov	 ecx, eax
  01108	c1 e9 08	 shr	 ecx, 8
  0110b	0f b6 c9	 movzx	 ecx, cl
  0110e	03 cb		 add	 ecx, ebx
  01110	3b ce		 cmp	 ecx, esi
  01112	77 ac		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);
; 1068 :                 state->back += last.bits;

  01114	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
  01117	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0111a	0f b6 ce	 movzx	 ecx, dh
  0111d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01120	d3 ea		 shr	 edx, cl
  01122	2b f1		 sub	 esi, ecx
  01124	89 8f c8 1b 00
	00		 mov	 DWORD PTR [edi+7112], ecx
  0112a	eb 03		 jmp	 SHORT $LN263@inflate
$LN937@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  0112c	8b 7d f4	 mov	 edi, DWORD PTR _state$1$[ebp]
$LN263@inflate:
  0112f	8b c8		 mov	 ecx, eax
  01131	c1 e9 08	 shr	 ecx, 8
  01134	0f b6 c9	 movzx	 ecx, cl

; 1071 :             state->back += here.bits;

  01137	01 8f c8 1b 00
	00		 add	 DWORD PTR [edi+7112], ecx
  0113d	2b f1		 sub	 esi, ecx
  0113f	d3 ea		 shr	 edx, cl

; 1072 :             state->length = (unsigned)here.val;

  01141	8b c8		 mov	 ecx, eax
  01143	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01146	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  01149	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0114c	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  0114f	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  01152	84 c0		 test	 al, al
  01154	75 09		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  01156	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  0115d	eb 2c		 jmp	 SHORT $LN934@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  0115f	a8 20		 test	 al, 32			; 00000020H
  01161	74 13		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  01163	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1083 :                 state->mode = TYPE;

  0116d	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  01174	eb 15		 jmp	 SHORT $LN934@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  01176	a8 40		 test	 al, 64			; 00000040H
  01178	74 36		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  0117a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0117d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
$LN977@inflate:

; 652  :     in = have;
; 653  :     out = left;
; 654  :     ret = Z_OK;
; 655  :     for (;;)
; 656  :         switch (state->mode) {

  01184	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN934@inflate:
  0118b	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
$LN8@inflate:
  0118e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01191	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
  01194	05 cc c0 ff ff	 add	 eax, -16180		; ffffc0ccH
  01199	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  0119c	0f 86 fe ee ff
	ff		 jbe	 $LL5@inflate
$LN333@inflate:
  011a2	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  011a3	5e		 pop	 esi
  011a4	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  011a9	5b		 pop	 ebx
  011aa	8b e5		 mov	 esp, ebp
  011ac	5d		 pop	 ebp
  011ad	c2 08 00	 ret	 8
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  011b0	0f b6 c0	 movzx	 eax, al
  011b3	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1092 :             state->mode = LENEXT;

  011b6	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  011bd	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  011c0	8b 79 4c	 mov	 edi, DWORD PTR [ecx+76]
  011c3	85 ff		 test	 edi, edi
  011c5	74 51		 je	 SHORT $LN753@inflate

; 1095 :                 NEEDBITS(state->extra);

  011c7	3b f7		 cmp	 esi, edi
  011c9	73 29		 jae	 SHORT $LN264@inflate
  011cb	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
  011ce	66 90		 npad	 2
$LL267@inflate:
  011d0	85 db		 test	 ebx, ebx
  011d2	0f 84 36 f4 ff
	ff		 je	 $LN933@inflate
  011d8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011db	8b ce		 mov	 ecx, esi
  011dd	d3 e0		 shl	 eax, cl
  011df	4b		 dec	 ebx
  011e0	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  011e3	42		 inc	 edx
  011e4	83 c6 08	 add	 esi, 8
  011e7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  011ea	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  011ed	3b f7		 cmp	 esi, edi
  011ef	72 df		 jb	 SHORT $LL267@inflate
  011f1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  011f4	8b cf		 mov	 ecx, edi
  011f6	b8 01 00 00 00	 mov	 eax, 1
  011fb	d3 e0		 shl	 eax, cl

; 1097 :                 DROPBITS(state->extra);

  011fd	2b f7		 sub	 esi, edi
  011ff	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01202	48		 dec	 eax
  01203	23 c2		 and	 eax, edx
  01205	01 41 44	 add	 DWORD PTR [ecx+68], eax
  01208	8b cf		 mov	 ecx, edi
  0120a	d3 ea		 shr	 edx, cl

; 1098 :                 state->back += state->extra;

  0120c	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0120f	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01212	01 b9 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], edi
$LN753@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  01218	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0121b	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  01221	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  01228	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  0122b	b8 01 00 00 00	 mov	 eax, 1
  01230	d3 e0		 shl	 eax, cl
  01232	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  01235	8b 45 f4	 mov	 eax, DWORD PTR _state$1$[ebp]
  01238	89 4d bc	 mov	 DWORD PTR tv5517[ebp], ecx
  0123b	23 ca		 and	 ecx, edx
  0123d	8b 78 54	 mov	 edi, DWORD PTR [eax+84]
  01240	89 7d c0	 mov	 DWORD PTR tv5554[ebp], edi
  01243	8b 04 8f	 mov	 eax, DWORD PTR [edi+ecx*4]
  01246	8b c8		 mov	 ecx, eax
  01248	c1 e9 08	 shr	 ecx, 8
  0124b	0f b6 c9	 movzx	 ecx, cl

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  0124e	3b ce		 cmp	 ecx, esi
  01250	76 3c		 jbe	 SHORT $LN574@inflate
  01252	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
$LL275@inflate:

; 1107 :                 PULLBYTE();

  01255	85 db		 test	 ebx, ebx
  01257	0f 84 b1 f3 ff
	ff		 je	 $LN933@inflate
  0125d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01260	8b ce		 mov	 ecx, esi
  01262	d3 e0		 shl	 eax, cl
  01264	4b		 dec	 ebx
  01265	8b 4d f8	 mov	 ecx, DWORD PTR _hold$1$[ebp]
  01268	42		 inc	 edx
  01269	03 c8		 add	 ecx, eax
  0126b	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  0126e	8b 45 bc	 mov	 eax, DWORD PTR tv5517[ebp]
  01271	83 c6 08	 add	 esi, 8
  01274	23 c1		 and	 eax, ecx
  01276	89 4d f8	 mov	 DWORD PTR _hold$1$[ebp], ecx
  01279	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  0127c	8b 04 87	 mov	 eax, DWORD PTR [edi+eax*4]
  0127f	8b c8		 mov	 ecx, eax
  01281	c1 e9 08	 shr	 ecx, 8
  01284	0f b6 c9	 movzx	 ecx, cl
  01287	3b ce		 cmp	 ecx, esi
  01289	77 ca		 ja	 SHORT $LL275@inflate
  0128b	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  0128e	a8 f0		 test	 al, 240			; 000000f0H
  01290	0f 85 a3 00 00
	00		 jne	 $LN938@inflate

; 1110 :                 last = here;

  01296	8b c8		 mov	 ecx, eax

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  01298	bf 01 00 00 00	 mov	 edi, 1
  0129d	c1 e9 08	 shr	 ecx, 8
  012a0	8b d0		 mov	 edx, eax
  012a2	0f b6 d9	 movzx	 ebx, cl
  012a5	0f b6 c8	 movzx	 ecx, al
  012a8	03 cb		 add	 ecx, ebx
  012aa	c1 e8 10	 shr	 eax, 16			; 00000010H
  012ad	d3 e7		 shl	 edi, cl
  012af	8b cb		 mov	 ecx, ebx
  012b1	4f		 dec	 edi
  012b2	89 55 cc	 mov	 DWORD PTR _last$[ebp], edx
  012b5	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  012b8	d3 ef		 shr	 edi, cl
  012ba	8b 4d c0	 mov	 ecx, DWORD PTR tv5554[ebp]
  012bd	03 f8		 add	 edi, eax
  012bf	8b 04 b9	 mov	 eax, DWORD PTR [ecx+edi*4]
  012c2	8b c8		 mov	 ecx, eax
  012c4	c1 e9 08	 shr	 ecx, 8

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  012c7	0f b6 c9	 movzx	 ecx, cl
  012ca	03 cb		 add	 ecx, ebx
  012cc	3b ce		 cmp	 ecx, esi
  012ce	76 54		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1115 :                     PULLBYTE();

  012d0	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  012d3	85 c0		 test	 eax, eax
  012d5	0f 84 36 f3 ff
	ff		 je	 $LN944@inflate
  012db	8b 5d ec	 mov	 ebx, DWORD PTR _next$1$[ebp]
  012de	48		 dec	 eax
  012df	89 45 f0	 mov	 DWORD PTR _have$1$[ebp], eax
  012e2	8b ce		 mov	 ecx, esi
  012e4	bf 01 00 00 00	 mov	 edi, 1
  012e9	83 c6 08	 add	 esi, 8
  012ec	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  012ef	43		 inc	 ebx
  012f0	d3 e0		 shl	 eax, cl
  012f2	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  012f5	0f b7 45 ce	 movzx	 eax, WORD PTR _last$[ebp+2]
  012f9	89 5d ec	 mov	 DWORD PTR _next$1$[ebp], ebx
  012fc	0f b6 de	 movzx	 ebx, dh
  012ff	0f b6 ca	 movzx	 ecx, dl
  01302	03 cb		 add	 ecx, ebx
  01304	d3 e7		 shl	 edi, cl
  01306	8b cb		 mov	 ecx, ebx
  01308	4f		 dec	 edi
  01309	23 7d f8	 and	 edi, DWORD PTR _hold$1$[ebp]
  0130c	d3 ef		 shr	 edi, cl
  0130e	03 f8		 add	 edi, eax
  01310	8b 45 c0	 mov	 eax, DWORD PTR tv5554[ebp]
  01313	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01316	8b c8		 mov	 ecx, eax
  01318	c1 e9 08	 shr	 ecx, 8
  0131b	0f b6 c9	 movzx	 ecx, cl
  0131e	03 cb		 add	 ecx, ebx
  01320	3b ce		 cmp	 ecx, esi
  01322	77 ac		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);
; 1118 :                 state->back += last.bits;

  01324	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
  01327	0f b6 ce	 movzx	 ecx, dh
  0132a	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
  0132d	2b f1		 sub	 esi, ecx
  0132f	d3 ea		 shr	 edx, cl
  01331	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  01337	eb 03		 jmp	 SHORT $LN292@inflate
$LN938@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  01339	8b 5d f4	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  0133c	8b c8		 mov	 ecx, eax
  0133e	c1 e9 08	 shr	 ecx, 8
  01341	0f b6 c9	 movzx	 ecx, cl

; 1121 :             state->back += here.bits;

  01344	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  0134a	2b f1		 sub	 esi, ecx
  0134c	d3 ea		 shr	 edx, cl
  0134e	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01351	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi

; 1122 :             if (here.op & 64) {

  01354	a8 40		 test	 al, 64			; 00000040H
  01356	74 15		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01358	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]

; 1124 :                 state->mode = BAD;

  0135b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1125 :                 break;

  0135e	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01361	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  01368	e9 17 fe ff ff	 jmp	 $LN977@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  0136d	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  0136f	0f b6 c0	 movzx	 eax, al
  01372	c1 e9 10	 shr	 ecx, 16			; 00000010H
  01375	83 e0 0f	 and	 eax, 15			; 0000000fH
  01378	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  0137b	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0137e	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01381	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  01384	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  0138b	8b 79 4c	 mov	 edi, DWORD PTR [ecx+76]
  0138e	85 ff		 test	 edi, edi
  01390	74 59		 je	 SHORT $LN755@inflate

; 1132 :                 NEEDBITS(state->extra);

  01392	3b f7		 cmp	 esi, edi
  01394	73 2e		 jae	 SHORT $LN293@inflate
  01396	8b 55 ec	 mov	 edx, DWORD PTR _next$1$[ebp]
  01399	0f 1f 80 00 00
	00 00		 npad	 7
$LL296@inflate:
  013a0	85 db		 test	 ebx, ebx
  013a2	0f 84 66 f2 ff
	ff		 je	 $LN933@inflate
  013a8	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  013ab	8b ce		 mov	 ecx, esi
  013ad	d3 e0		 shl	 eax, cl
  013af	4b		 dec	 ebx
  013b0	01 45 f8	 add	 DWORD PTR _hold$1$[ebp], eax
  013b3	42		 inc	 edx
  013b4	83 c6 08	 add	 esi, 8
  013b7	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  013ba	89 55 ec	 mov	 DWORD PTR _next$1$[ebp], edx
  013bd	3b f7		 cmp	 esi, edi
  013bf	72 df		 jb	 SHORT $LL296@inflate
  013c1	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  013c4	8b cf		 mov	 ecx, edi
  013c6	b8 01 00 00 00	 mov	 eax, 1
  013cb	d3 e0		 shl	 eax, cl

; 1134 :                 DROPBITS(state->extra);

  013cd	2b f7		 sub	 esi, edi
  013cf	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013d2	48		 dec	 eax
  013d3	23 c2		 and	 eax, edx
  013d5	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  013d8	01 41 48	 add	 DWORD PTR [ecx+72], eax
  013db	8b cf		 mov	 ecx, edi
  013dd	d3 ea		 shr	 edx, cl

; 1135 :                 state->back += state->extra;

  013df	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  013e2	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  013e5	01 b9 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], edi
$LN755@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  013eb	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  013f2	8b 7d e4	 mov	 edi, DWORD PTR _left$1$[ebp]
  013f5	85 ff		 test	 edi, edi
  013f7	0f 84 11 f2 ff
	ff		 je	 $LN933@inflate

; 1148 :             copy = out - left;

  013fd	8b 45 d8	 mov	 eax, DWORD PTR _out$1$[ebp]
  01400	2b c7		 sub	 eax, edi

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01402	8b 79 48	 mov	 edi, DWORD PTR [ecx+72]
  01405	3b f8		 cmp	 edi, eax
  01407	76 4b		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01409	2b f8		 sub	 edi, eax

; 1151 :                 if (copy > state->whave) {

  0140b	3b 79 30	 cmp	 edi, DWORD PTR [ecx+48]
  0140e	76 18		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  01410	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01417	74 0f		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01419	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0141c	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1154 :                         state->mode = BAD;
; 1155 :                         break;

  01423	e9 5c fd ff ff	 jmp	 $LN977@inflate
$LN479@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01428	8b 59 34	 mov	 ebx, DWORD PTR [ecx+52]
  0142b	3b fb		 cmp	 edi, ebx
  0142d	76 0c		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;
; 1173 :                     from = state->window + (state->wsize - copy);

  0142f	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  01432	2b fb		 sub	 edi, ebx
  01434	2b c7		 sub	 eax, edi
  01436	03 41 38	 add	 eax, DWORD PTR [ecx+56]

; 1174 :                 }

  01439	eb 07		 jmp	 SHORT $LN976@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  0143b	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  0143e	2b c7		 sub	 eax, edi
  01440	03 c3		 add	 eax, ebx
$LN976@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  01442	89 45 c8	 mov	 DWORD PTR _from$1$[ebp], eax
  01445	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 1178 :             }

  01448	3b f8		 cmp	 edi, eax
  0144a	8b d8		 mov	 ebx, eax
  0144c	0f 46 df	 cmovbe	 ebx, edi
  0144f	89 5d c0	 mov	 DWORD PTR _copy$7$[ebp], ebx
  01452	eb 0e		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  01454	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  01457	2b c7		 sub	 eax, edi
  01459	89 45 c8	 mov	 DWORD PTR _from$1$[ebp], eax

; 1181 :                 copy = state->length;

  0145c	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  0145f	89 45 c0	 mov	 DWORD PTR _copy$7$[ebp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;
; 1184 :             left -= copy;

  01462	8b 7d e4	 mov	 edi, DWORD PTR _left$1$[ebp]
  01465	8b 5d c0	 mov	 ebx, DWORD PTR _copy$7$[ebp]
  01468	3b df		 cmp	 ebx, edi

; 1185 :             state->length -= copy;

  0146a	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0146d	0f 46 fb	 cmovbe	 edi, ebx
  01470	8b 5d c8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  01473	29 7d e4	 sub	 DWORD PTR _left$1$[ebp], edi
  01476	2b c7		 sub	 eax, edi
  01478	89 41 44	 mov	 DWORD PTR [ecx+68], eax
  0147b	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0147e	2b d9		 sub	 ebx, ecx
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01480	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01483	88 01		 mov	 BYTE PTR [ecx], al
  01485	41		 inc	 ecx

; 1188 :             } while (--copy);

  01486	83 ef 01	 sub	 edi, 1
  01489	75 f5		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  0148b	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0148e	89 4d dc	 mov	 DWORD PTR _put$1$[ebp], ecx
  01491	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01494	39 79 44	 cmp	 DWORD PTR [ecx+68], edi
  01497	0f 85 ee fc ff
	ff		 jne	 $LN934@inflate
  0149d	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1190 :             break;

  014a4	e9 e2 fc ff ff	 jmp	 $LN934@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  014a9	83 7d e4 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  014ad	0f 84 5b f1 ff
	ff		 je	 $LN933@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  014b3	8b 5d dc	 mov	 ebx, DWORD PTR _put$1$[ebp]
  014b6	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  014b9	ff 45 dc	 inc	 DWORD PTR _put$1$[ebp]

; 1194 :             left--;

  014bc	ff 4d e4	 dec	 DWORD PTR _left$1$[ebp]
  014bf	88 03		 mov	 BYTE PTR [ebx], al

; 1195 :             state->mode = LEN;
; 1196 :             break;

  014c1	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  014c4	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  014cb	e9 be fc ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  014d0	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  014d4	0f 84 ec 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  014da	83 fe 20	 cmp	 esi, 32			; 00000020H
  014dd	73 2b		 jae	 SHORT $LN307@inflate
  014df	90		 npad	 1
$LL310@inflate:
  014e0	85 db		 test	 ebx, ebx
  014e2	0f 84 26 f1 ff
	ff		 je	 $LN933@inflate
  014e8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  014eb	8b ce		 mov	 ecx, esi
  014ed	d3 e0		 shl	 eax, cl
  014ef	83 c6 08	 add	 esi, 8
  014f2	4b		 dec	 ebx
  014f3	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  014f6	03 d0		 add	 edx, eax
  014f8	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  014fb	47		 inc	 edi
  014fc	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  014ff	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01502	83 fe 20	 cmp	 esi, 32			; 00000020H
  01505	72 d9		 jb	 SHORT $LL310@inflate
  01507	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1200 :                 out -= left;

  0150a	8b 45 e4	 mov	 eax, DWORD PTR _left$1$[ebp]
  0150d	29 45 d8	 sub	 DWORD PTR _out$1$[ebp], eax

; 1201 :                 strm->total_out += out;

  01510	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01513	8b 7d d8	 mov	 edi, DWORD PTR _out$1$[ebp]
  01516	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1202 :                 state->total += out;

  01519	8b c7		 mov	 eax, edi
  0151b	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  0151e	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  01521	8b 7d ec	 mov	 edi, DWORD PTR _next$1$[ebp]
  01524	a8 04		 test	 al, 4
  01526	74 38		 je	 SHORT $LN490@inflate
  01528	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  0152c	74 32		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  0152e	8b 45 dc	 mov	 eax, DWORD PTR _put$1$[ebp]
  01531	ff 75 d8	 push	 DWORD PTR _out$1$[ebp]
  01534	2b 45 d8	 sub	 eax, DWORD PTR _out$1$[ebp]
  01537	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  0153b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0153e	50		 push	 eax
  0153f	52		 push	 edx
  01540	74 07		 je	 SHORT $LN511@inflate
  01542	e8 00 00 00 00	 call	 _crc32@12
  01547	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  01549	e8 00 00 00 00	 call	 _adler32@12
$LN512@inflate:
  0154e	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01551	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01554	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  01557	89 42 30	 mov	 DWORD PTR [edx+48], eax
  0155a	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0155d	8b 55 f8	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;

  01560	8b 5d e4	 mov	 ebx, DWORD PTR _left$1$[ebp]
  01563	89 5d d8	 mov	 DWORD PTR _out$1$[ebp], ebx

; 1207 :                 if ((state->wrap & 4) && (

  01566	8b 5d f0	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01569	a8 04		 test	 al, 4
  0156b	74 4f		 je	 SHORT $LN317@inflate
  0156d	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01571	8b c2		 mov	 eax, edx
  01573	75 2c		 jne	 SHORT $LN514@inflate
  01575	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0157a	89 45 d4	 mov	 DWORD PTR tv5697[ebp], eax
  0157d	8b c2		 mov	 eax, edx
  0157f	c1 e0 10	 shl	 eax, 16			; 00000010H
  01582	01 45 d4	 add	 DWORD PTR tv5697[ebp], eax
  01585	8b c2		 mov	 eax, edx
  01587	c1 65 d4 08	 shl	 DWORD PTR tv5697[ebp], 8
  0158b	c1 e8 08	 shr	 eax, 8
  0158e	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01593	01 45 d4	 add	 DWORD PTR tv5697[ebp], eax
  01596	8b c2		 mov	 eax, edx
  01598	c1 e8 18	 shr	 eax, 24			; 00000018H
  0159b	01 45 d4	 add	 DWORD PTR tv5697[ebp], eax
  0159e	8b 45 d4	 mov	 eax, DWORD PTR tv5697[ebp]
$LN514@inflate:
  015a1	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  015a4	74 16		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  015a6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015a9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  015b0	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  015b7	e9 d2 fb ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  015bc	33 d2		 xor	 edx, edx
  015be	33 f6		 xor	 esi, esi
  015c0	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  015c3	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  015c6	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  015cd	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  015d1	0f 84 88 00 00
	00		 je	 $LN327@inflate
  015d7	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  015db	0f 84 7e 00 00
	00		 je	 $LN327@inflate

; 1223 :                 NEEDBITS(32);

  015e1	83 fe 20	 cmp	 esi, 32			; 00000020H
  015e4	73 2a		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  015e6	85 db		 test	 ebx, ebx
  015e8	0f 84 20 f0 ff
	ff		 je	 $LN933@inflate
  015ee	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  015f1	8b ce		 mov	 ecx, esi
  015f3	d3 e0		 shl	 eax, cl
  015f5	83 c6 08	 add	 esi, 8
  015f8	4b		 dec	 ebx
  015f9	89 75 e8	 mov	 DWORD PTR _bits$1$[ebp], esi
  015fc	03 d0		 add	 edx, eax
  015fe	89 5d f0	 mov	 DWORD PTR _have$1$[ebp], ebx
  01601	47		 inc	 edi
  01602	89 55 f8	 mov	 DWORD PTR _hold$1$[ebp], edx
  01605	89 7d ec	 mov	 DWORD PTR _next$1$[ebp], edi
  01608	83 fe 20	 cmp	 esi, 32			; 00000020H
  0160b	72 d9		 jb	 SHORT $LL321@inflate
  0160d	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01610	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01613	74 41		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01615	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01618	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  0161f	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  01626	e9 63 fb ff ff	 jmp	 $LN8@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  0162b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0162e	8b 4d dc	 mov	 ecx, DWORD PTR _put$1$[ebp]
  01631	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  01634	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  01637	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0163a	8b 4d f4	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0163d	89 38		 mov	 DWORD PTR [eax], edi
  0163f	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 845  :                 return Z_NEED_DICT;

  01642	b8 02 00 00 00	 mov	 eax, 2
  01647	5f		 pop	 edi
  01648	89 71 40	 mov	 DWORD PTR [ecx+64], esi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0164b	5e		 pop	 esi
  0164c	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  0164f	5b		 pop	 ebx
  01650	8b e5		 mov	 esp, ebp
  01652	5d		 pop	 ebp
  01653	c2 08 00	 ret	 8
$LN328@inflate:

; 1226 :                     state->mode = BAD;
; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  01656	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  0165d	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  0165f	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  01666	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1236 :             goto inf_leave;

  0166d	e9 9c ef ff ff	 jmp	 $LN933@inflate
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  01672	c7 45 d0 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  01679	e9 90 ef ff ff	 jmp	 $LN933@inflate
$LN909@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  0167e	8b 45 f0	 mov	 eax, DWORD PTR _have$1$[ebp]
  01681	e9 8e ef ff ff	 jmp	 $inf_leave$981
$LN503@inflate:

; 1259 :             return Z_MEM_ERROR;
; 1260 :         }
; 1261 :     in -= strm->avail_in;

  01686	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  01689	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  0168c	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  0168f	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  01692	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1265 :     state->total += out;

  01695	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1266 :     if ((state->wrap & 4) && out)

  01698	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  0169c	89 45 c4	 mov	 DWORD PTR _in$1$[ebp], eax
  0169f	89 75 d8	 mov	 DWORD PTR _out$1$[ebp], esi
  016a2	74 27		 je	 SHORT $LN504@inflate
  016a4	85 f6		 test	 esi, esi
  016a6	74 23		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  016a8	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  016ab	8b 4b 1c	 mov	 ecx, DWORD PTR [ebx+28]
  016ae	2b c6		 sub	 eax, esi
  016b0	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  016b4	56		 push	 esi
  016b5	50		 push	 eax
  016b6	51		 push	 ecx
  016b7	74 07		 je	 SHORT $LN515@inflate
  016b9	e8 00 00 00 00	 call	 _crc32@12
  016be	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  016c0	e8 00 00 00 00	 call	 _adler32@12
$LN516@inflate:
  016c5	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  016c8	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  016cb	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  016ce	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  016d4	74 0c		 je	 SHORT $LN517@inflate
  016d6	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  016dc	74 04		 je	 SHORT $LN517@inflate
  016de	33 f6		 xor	 esi, esi
  016e0	eb 05		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  016e2	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN518@inflate:
  016e7	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  016ea	f7 d9		 neg	 ecx
  016ec	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv5493[ebp], 128 ; 00000080H
  016f3	1b c9		 sbb	 ecx, ecx
  016f5	33 c0		 xor	 eax, eax
  016f7	83 e1 40	 and	 ecx, 64			; 00000040H
  016fa	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01700	0f 44 45 08	 cmove	 eax, DWORD PTR tv5493[ebp]
  01704	03 ce		 add	 ecx, esi
  01706	03 c1		 add	 eax, ecx
  01708	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0170b	83 7d c4 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  0170f	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  01712	75 06		 jne	 SHORT $LN507@inflate
  01714	83 7d d8 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  01718	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  0171a	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0171e	75 16		 jne	 SHORT $LN942@inflate
$LN506@inflate:
  01720	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01723	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  01728	5f		 pop	 edi
  01729	85 c0		 test	 eax, eax

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0172b	5e		 pop	 esi
  0172c	0f 44 c1	 cmove	 eax, ecx
  0172f	5b		 pop	 ebx
  01730	8b e5		 mov	 esp, ebp
  01732	5d		 pop	 ebp
  01733	c2 08 00	 ret	 8
$LN942@inflate:

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01736	8b 45 d0	 mov	 eax, DWORD PTR _ret$1$[ebp]
  01739	5f		 pop	 edi

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  0173a	5e		 pop	 esi
  0173b	5b		 pop	 ebx
  0173c	8b e5		 mov	 esp, ebp
  0173e	5d		 pop	 ebp
  0173f	c2 08 00	 ret	 8
  01742	66 90		 npad	 2
$LN815@inflate:
  01744	00 00 00 00	 DD	 $LN335@inflate
  01748	00 00 00 00	 DD	 $LN32@inflate
  0174c	00 00 00 00	 DD	 $LN46@inflate
  01750	00 00 00 00	 DD	 $LN60@inflate
  01754	00 00 00 00	 DD	 $LN361@inflate
  01758	00 00 00 00	 DD	 $LN368@inflate
  0175c	00 00 00 00	 DD	 $LN375@inflate
  01760	00 00 00 00	 DD	 $LN384@inflate
  01764	00 00 00 00	 DD	 $LN393@inflate
  01768	00 00 00 00	 DD	 $LN105@inflate
  0176c	00 00 00 00	 DD	 $LN400@inflate
  01770	00 00 00 00	 DD	 $LN402@inflate
  01774	00 00 00 00	 DD	 $LN403@inflate
  01778	00 00 00 00	 DD	 $LN141@inflate
  0177c	00 00 00 00	 DD	 $LN416@inflate
  01780	00 00 00 00	 DD	 $LN418@inflate
  01784	00 00 00 00	 DD	 $LN155@inflate
  01788	00 00 00 00	 DD	 $LN532@inflate
  0178c	00 00 00 00	 DD	 $LN535@inflate
  01790	00 00 00 00	 DD	 $LN448@inflate
  01794	00 00 00 00	 DD	 $LN450@inflate
  01798	00 00 00 00	 DD	 $LN461@inflate
  0179c	00 00 00 00	 DD	 $LN464@inflate
  017a0	00 00 00 00	 DD	 $LN471@inflate
  017a4	00 00 00 00	 DD	 $LN474@inflate
  017a8	00 00 00 00	 DD	 $LN485@inflate
  017ac	00 00 00 00	 DD	 $LN487@inflate
  017b0	00 00 00 00	 DD	 $LN492@inflate
  017b4	00 00 00 00	 DD	 $LN496@inflate
  017b8	00 00 00 00	 DD	 $LN497@inflate
  017bc	00 00 00 00	 DD	 $LN498@inflate
$LN816@inflate:
  017c0	00 00 00 00	 DD	 $LN408@inflate
  017c4	00 00 00 00	 DD	 $LN409@inflate
  017c8	00 00 00 00	 DD	 $LN411@inflate
  017cc	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1289 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0f		 je	 SHORT $LN3@inflateEnd
  00026	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00029	51		 push	 ecx
  0002a	ff 76 28	 push	 DWORD PTR [esi+40]
  0002d	ff d0		 call	 eax
  0002f	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00032	83 c4 08	 add	 esp, 8
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00035	50		 push	 eax
  00036	ff 76 28	 push	 DWORD PTR [esi+40]
  00039	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0003c	ff d0		 call	 eax
  0003e	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  00041	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 1289 : }

  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 27		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 21		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1b		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 14		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 10		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00023	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00026	77 03		 ja	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 117  : }

  0002a	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00030	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  00073	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0007a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00081	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00088	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00092	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 142  : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  0000b	57		 push	 edi
  0000c	e8 00 00 00 00	 call	 _inflateStateCheck
  00011	85 c0		 test	 eax, eax
  00013	75 60		 jne	 SHORT $LN7@inflateRes

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00015	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00018	85 f6		 test	 esi, esi
  0001a	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0001c	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0001e	f7 de		 neg	 esi

; 172  :     }

  00020	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00022	8b fe		 mov	 edi, esi
  00024	c1 ef 04	 shr	 edi, 4
  00027	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0002a	83 fe 30	 cmp	 esi, 48			; 00000030H
  0002d	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0002f	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00032	85 f6		 test	 esi, esi
  00034	74 0a		 je	 SHORT $LN6@inflateRes
  00036	83 fe 08	 cmp	 esi, 8
  00039	7c 3a		 jl	 SHORT $LN7@inflateRes
  0003b	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003e	7f 35		 jg	 SHORT $LN7@inflateRes
$LN6@inflateRes:

; 183  :         return Z_STREAM_ERROR;
; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00040	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  00043	85 c0		 test	 eax, eax
  00045	74 1b		 je	 SHORT $LN8@inflateRes
  00047	39 73 28	 cmp	 DWORD PTR [ebx+40], esi
  0004a	74 16		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  0004c	50		 push	 eax
  0004d	ff 71 28	 push	 DWORD PTR [ecx+40]
  00050	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00053	ff d0		 call	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00058	83 c4 08	 add	 esp, 8

; 186  :         state->window = Z_NULL;

  0005b	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [ebx+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  00062	51		 push	 ecx
  00063	89 7b 0c	 mov	 DWORD PTR [ebx+12], edi
  00066	89 73 28	 mov	 DWORD PTR [ebx+40], esi
  00069	e8 00 00 00 00	 call	 _inflateReset@4
  0006e	5f		 pop	 edi

; 193  : }

  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	5d		 pop	 ebp
  00072	c2 08 00	 ret	 8
$LN7@inflateRes:
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	75 43		 jne	 SHORT $LN5@inflatePri

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00011	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 256  :     if (bits < 0) {

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00017	85 c9		 test	 ecx, ecx
  00019	79 0c		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  0001b	5f		 pop	 edi
  0001c	89 42 3c	 mov	 DWORD PTR [edx+60], eax

; 258  :         state->bits = 0;

  0001f	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 266  : }

  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:

; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00027	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0002a	7f 28		 jg	 SHORT $LN5@inflatePri
  0002c	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  0002f	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00032	83 ff 20	 cmp	 edi, 32			; 00000020H
  00035	77 1d		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00037	b8 01 00 00 00	 mov	 eax, 1

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  0003c	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  0003f	d3 e0		 shl	 eax, cl
  00041	8b ce		 mov	 ecx, esi
  00043	48		 dec	 eax
  00044	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00047	d3 e0		 shl	 eax, cl
  00049	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 265  :     return Z_OK;

  0004c	33 c0		 xor	 eax, eax
  0004e	5f		 pop	 edi

; 266  : }

  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflatePri:
  00054	5f		 pop	 edi

; 259  :         return Z_OK;
; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  0005a	5e		 pop	 esi
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
$T1 = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b da		 mov	 ebx, edx
  00007	8b d1		 mov	 edx, ecx
  00009	56		 push	 esi

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  0000a	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000d	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00010	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00013	85 c0		 test	 eax, eax
  00015	75 2d		 jne	 SHORT $LN15@updatewind

; 408  :         state->window = (unsigned char FAR *)

  00017	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	d3 e0		 shl	 eax, cl
  00021	6a 01		 push	 1
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00032	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00035	85 c0		 test	 eax, eax
  00037	75 0b		 jne	 SHORT $LN15@updatewind
  00039	5e		 pop	 esi
  0003a	b8 01 00 00 00	 mov	 eax, 1

; 444  : }

  0003f	5b		 pop	 ebx
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
$LN15@updatewind:
  00044	57		 push	 edi

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00045	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00048	85 ff		 test	 edi, edi
  0004a	75 1b		 jne	 SHORT $LN14@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0004c	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004f	bf 01 00 00 00	 mov	 edi, 1
  00054	d3 e7		 shl	 edi, cl
  00056	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 417  :         state->wnext = 0;

  00059	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 418  :         state->whave = 0;

  00060	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN14@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  00067	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]
  0006a	3b d7		 cmp	 edx, edi
  0006c	72 23		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  0006e	57		 push	 edi
  0006f	2b df		 sub	 ebx, edi
  00071	53		 push	 ebx
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00078	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 441  :         }
; 442  :     }
; 443  :     return 0;

  0007e	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00081	33 c0		 xor	 eax, eax
  00083	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 444  : }

  0008c	5b		 pop	 ebx
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
$LN5@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  00091	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 429  :         if (dist > copy) dist = copy;
; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00094	8b c3		 mov	 eax, ebx
  00096	3b fa		 cmp	 edi, edx
  00098	0f 47 fa	 cmova	 edi, edx
  0009b	2b c2		 sub	 eax, edx
  0009d	57		 push	 edi
  0009e	50		 push	 eax
  0009f	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000a2	03 46 34	 add	 eax, DWORD PTR [esi+52]
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 _memcpy

; 431  :         copy -= dist;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _copy$[ebp]
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	2b c7		 sub	 eax, edi
  000b3	89 45 08	 mov	 DWORD PTR _copy$[ebp], eax

; 432  :         if (copy) {

  000b6	74 24		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000b8	50		 push	 eax
  000b9	2b d8		 sub	 ebx, eax
  000bb	53		 push	 ebx
  000bc	ff 76 38	 push	 DWORD PTR [esi+56]
  000bf	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000c4	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	8b 55 08	 mov	 edx, DWORD PTR _copy$[ebp]

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000cd	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000d0	33 c0		 xor	 eax, eax
  000d2	89 56 34	 mov	 DWORD PTR [esi+52], edx
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi

; 444  : }

  000d7	5b		 pop	 ebx
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	c3		 ret	 0
$LN8@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;

  000dc	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000df	33 d2		 xor	 edx, edx
  000e1	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000e4	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  000e7	0f 44 c2	 cmove	 eax, edx
  000ea	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000ed	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000f0	3b 46 2c	 cmp	 eax, DWORD PTR [esi+44]
  000f3	73 05		 jae	 SHORT $LN11@updatewind
  000f5	03 c7		 add	 eax, edi

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000f7	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	33 c0		 xor	 eax, eax

; 444  : }

  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 2f		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 26		 je	 SHORT $LN6@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003f	2b f8		 sub	 edi, eax
  00041	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00044	50		 push	 eax
  00045	ff 76 38	 push	 DWORD PTR [esi+56]
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  00051	5f		 pop	 edi
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00055	85 c9		 test	 ecx, ecx
  00057	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00059	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 1312 : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00008	8b cf		 mov	 ecx, edi
  0000a	e8 00 00 00 00	 call	 _inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 7c		 jne	 SHORT $LN10@inflateSet

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  00013	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00016	39 46 0c	 cmp	 DWORD PTR [esi+12], eax
  00019	74 09		 je	 SHORT $LN9@inflateSet
  0001b	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  00022	75 6b		 jne	 SHORT $LN10@inflateSet
$LN9@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00024	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0002b	53		 push	 ebx
  0002c	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  0002f	75 26		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 _adler32@12

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0003c	53		 push	 ebx
  0003d	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 _adler32@12

; 1333 :         if (dictid != state->check)

  00046	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  00049	74 0c		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0004b	5b		 pop	 ebx
  0004c	5f		 pop	 edi
  0004d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1347 : }

  00052	5e		 pop	 esi
  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  00057	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  0005a	8b cf		 mov	 ecx, edi
  0005c	53		 push	 ebx
  0005d	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00060	e8 00 00 00 00	 call	 _updatewindow
  00065	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  00068	85 c0		 test	 eax, eax
  0006a	74 13		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  0006c	5b		 pop	 ebx
  0006d	5f		 pop	 edi
  0006e	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  00075	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH

; 1347 : }

  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:
  0007f	5b		 pop	 ebx
  00080	5f		 pop	 edi

; 1343 :     }
; 1344 :     state->havedict = 1;

  00081	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00088	33 c0		 xor	 eax, eax

; 1347 : }

  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH
$LN10@inflateSet:
  0008f	5f		 pop	 edi

; 1327 :         return Z_STREAM_ERROR;

  00090	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1347 : }

  00095	5e		 pop	 esi
  00096	5d		 pop	 ebp
  00097	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	75 1c		 jne	 SHORT $LN5@inflateGet

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0000f	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00012	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  00016	74 13		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0001b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1362 :     head->done = 0;

  0001e	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1363 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1364 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN5@inflateGet:

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1386 :     next = 0;
; 1387 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1394 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  00062	8b c6		 mov	 eax, esi

; 1398 : }

  00064	5e		 pop	 esi
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi

; 1398 : }

  0006e	5e		 pop	 esi
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
tv385 = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 1441 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001c	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0001f	57		 push	 edi
  00020	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00023	85 c0		 test	 eax, eax
  00025	75 11		 jne	 SHORT $LN15@inflateSyn
  00027	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002b	73 0b		 jae	 SHORT $LN15@inflateSyn
  0002d	5f		 pop	 edi
  0002e	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00033	5b		 pop	 ebx

; 1441 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN15@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00038	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0003f	56		 push	 esi
  00040	74 58		 je	 SHORT $LN13@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00042	8b 57 40	 mov	 edx, DWORD PTR [edi+64]
  00045	8b ca		 mov	 ecx, edx
  00047	8b 77 3c	 mov	 esi, DWORD PTR [edi+60]
  0004a	83 e1 07	 and	 ecx, 7
  0004d	d3 e6		 shl	 esi, cl

; 1417 :         state->bits -= state->bits & 7;

  0004f	2b d1		 sub	 edx, ecx

; 1418 :         len = 0;

  00051	33 c9		 xor	 ecx, ecx
  00053	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0005a	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  0005d	89 57 40	 mov	 DWORD PTR [edi+64], edx

; 1419 :         while (state->bits >= 8) {

  00060	83 fa 08	 cmp	 edx, 8
  00063	72 19		 jb	 SHORT $LN3@inflateSyn
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00065	8a 47 3c	 mov	 al, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00068	83 ea 08	 sub	 edx, 8
  0006b	88 44 0d 08	 mov	 BYTE PTR _buf$[ebp+ecx], al
  0006f	41		 inc	 ecx
  00070	c1 ee 08	 shr	 esi, 8
  00073	89 77 3c	 mov	 DWORD PTR [edi+60], esi
  00076	83 fa 08	 cmp	 edx, 8
  00079	73 ea		 jae	 SHORT $LL2@inflateSyn
  0007b	89 57 40	 mov	 DWORD PTR [edi+64], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0007e	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  00081	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  00084	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0008a	51		 push	 ecx
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 _syncsearch
  00092	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00095	83 c4 04	 add	 esp, 4
  00098	eb 03		 jmp	 SHORT $LN6@inflateSyn
$LN13@inflateSyn:
  0009a	8d 77 6c	 lea	 esi, DWORD PTR [edi+108]
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  0009d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009f	8b ce		 mov	 ecx, esi
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;

  000a7	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000aa	83 c4 04	 add	 esp, 4

; 1431 :     strm->next_in += len;

  000ad	01 03		 add	 DWORD PTR [ebx], eax

; 1432 :     strm->total_in += len;

  000af	03 43 08	 add	 eax, DWORD PTR [ebx+8]
  000b2	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000b5	83 3e 04	 cmp	 DWORD PTR [esi], 4
  000b8	89 45 08	 mov	 DWORD PTR tv385[ebp], eax
  000bb	74 0c		 je	 SHORT $LN7@inflateSyn
  000bd	5e		 pop	 esi
  000be	5f		 pop	 edi
  000bf	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000c4	5b		 pop	 ebx

; 1441 : }

  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000c9	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000cc	53		 push	 ebx
  000cd	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000d2	8b 45 08	 mov	 eax, DWORD PTR tv385[ebp]
  000d5	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000d8	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000db	33 c0		 xor	 eax, eax
  000dd	5e		 pop	 esi
  000de	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000e5	5f		 pop	 edi
  000e6	5b		 pop	 ebx

; 1441 : }

  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1459 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 2e 01 00
	00		 jne	 $LN3@inflateCop
  00016	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  00019	0f 84 25 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0001f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00022	53		 push	 ebx
  00023	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00026	56		 push	 esi
  00027	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002c	6a 01		 push	 1
  0002e	ff 77 28	 push	 DWORD PTR [edi+40]
  00031	ff d0		 call	 eax
  00033	8b f0		 mov	 esi, eax
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00038	85 f6		 test	 esi, esi
  0003a	74 38		 je	 SHORT $LN14@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  0003c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00040	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00047	74 37		 je	 SHORT $LN11@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00049	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	d3 e0		 shl	 eax, cl
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	ff 77 28	 push	 DWORD PTR [edi+40]
  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005c	ff d0		 call	 eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN11@inflateCop

; 1484 :             ZFREE(source, copy);

  00068	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0006b	56		 push	 esi
  0006c	ff 77 28	 push	 DWORD PTR [edi+40]
  0006f	ff d0		 call	 eax
  00071	83 c4 08	 add	 esp, 8
$LN14@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007b	5f		 pop	 edi

; 1506 : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN11@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00080	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00083	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00086	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008b	53		 push	 ebx
  0008c	56		 push	 esi
  0008d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00090	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  00094	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00098	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  0009c	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000a0	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000a5	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000aa	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000af	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1493 :     if (state->lencode >= state->codes &&

  000b2	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000b8	89 3e		 mov	 DWORD PTR [esi], edi
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000c0	3b c8		 cmp	 ecx, eax
  000c2	72 38		 jb	 SHORT $LN7@inflateCop
  000c4	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	77 2e		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000ce	2b cb		 sub	 ecx, ebx
  000d0	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000de	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e1	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e4	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000e7	2b c3		 sub	 eax, ebx
  000e9	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000f6	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f9	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000fc	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  000ff	2b c3		 sub	 eax, ebx
  00101	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00106	c1 f8 02	 sar	 eax, 2
  00109	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  0010e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00111	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1499 :     if (window != Z_NULL) {

  00114	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00117	85 c0		 test	 eax, eax
  00119	74 1a		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0011b	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	d3 e2		 shl	 edx, cl

; 1501 :         zmemcpy(window, state->window, wsize);

  00125	52		 push	 edx
  00126	ff 73 38	 push	 DWORD PTR [ebx+56]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _memcpy
  0012f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00135	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00138	33 c0		 xor	 eax, eax
  0013a	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	5f		 pop	 edi

; 1506 : }

  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00144	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00149	5f		 pop	 edi

; 1506 : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001b	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]

; 1534 :     if (check)
; 1535 :         state->wrap |= 4;
; 1536 :     else
; 1537 :         state->wrap &= ~4;
; 1538 :     return Z_OK;

  0001e	8b c1		 mov	 eax, ecx
  00020	83 e0 fb	 and	 eax, -5			; fffffffbH
  00023	83 c9 04	 or	 ecx, 4
  00026	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0002a	0f 44 c8	 cmove	 ecx, eax
  0002d	33 c0		 xor	 eax, eax
  0002f	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1539 : }

  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File G:\C_Library\zlib-VS\zlib-1.2.11\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1561 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
